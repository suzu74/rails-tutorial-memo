# Rails tutorial memo

## 20200625

### 第1章 ゼロからデプロイまで

* Railsだけでしか使えない基礎的な知識に基づくのではなく、ウェブ開発の基礎を学ぶことを重点とした高度な技術について学ぶ。
* 技術的に困難な課題を解決するために必要なのはスキルは2つのスキル（熟練）が必要
    * ハードスキル (操作方法などの定型化しやすいスキル) 
    * ソフトスキル (デバッグなどの定型化しにくいスキル)
* 技術は知っていればよいというものではなく、エラーメッセージを検索して調べたりなど見極める力も必要。
    * デバッグとかをつい怠ってしまうと感じている。`Rails.logger`や`◯◯.inspect`をもっと使うことも意識する。 
* 改めてRails tutorialで学べることが多くて驚いている。
    * MVCやREST、ジェネレータ、マイグレーション、ルーティング、ERBなどなど、今まではなんとなくで理解していたものが多いので、言葉で説明できるようにしたい。

#### 1.1 はじめに

* Rubyが柔軟性があるからこそ、Railsが簡潔で使いやすくなっている。
    * DSL (ドメイン固有言語) ???　⇨　https://www.jetbrains.com/ja-jp/mps/concepts/domain-specific-languages/
* Railsは最新のWebテクノロジーやフレームワーク設計に素早く適応している。だからこそ進化が早い。
* 多様なコミュニティがあるから、エラーに遭遇すると検索すれば関連する情報がすぐ見つかる。


##### 1.1.1 前提知識

* Rails チュートリアルでもProgateが紹介されているとは驚いた。
* 演習
    * Ruby gemはどのWebサイトにありますか？
        * https://rubygems.org/
    * 現時点でのRailsの最新バージョンはいくつですか？
        * Ruby on Rails 6.0.3
    * Ruby on Railsはこれまでに何回ダウンロードされたでしょうか？
        * すぐにはみつからず、、、。

##### 1.1.2 この本における取り決め

* エラーメッセージをGoogleで検索することは、実際の現場でも使われている基本的なテクニック
    * 何かわからなければ随時調べる。

#### 1.2 さっそく動かす

* ここからRubyなどのインストールを開始。久しぶりに開発環境を整える。
* 一番最初にチュートリアルをやったときはAWS Cloud9(クラウドIDE)だったのがなんだか懐かしい、、、、
    * 無事rails newができた、、、

## 20200626

##### 1.2.1 開発環境

* Cloud9は使わないので割愛

##### 1.2.1 Railsをインストールする

* インストール済み

#### 1.3 最初のアプリケーション

* Webフレームワークではディレクトリとファイルの構造は標準化されている。そのメリットがファイル/ディレクトリ構造が標準化されていることで他の開発者の書いたRailsのコードが読みやすくなること。
* rails new実行！

##### 1.3.1 Bundler

* gem 'uglifier', '>= 1.3.0' だったら、1.3.0以上なら最新をインストール。
* gem 'coffee-rails', '~> 4.0.0'だったら、4.0.0より大きく4.1より小さい場合にインストール。

##### 1.3.2 rails server

* 演習
    * Rubyのバージョンはいくつになっていますか?
        *  2.7.1
    * Railsのバージョンはいくつになっていますか?
        * 5.2.4.3

##### 1.3.3 Model-View-Controller (MVC)

* RailsはMVC (model-view-controller) というアーキテクチャパターンを採用している。MVCでは、アプリケーション内のデータ（ユーザー情報など）と、データを表示するコードを分離している。
* Model
    * アプリケーションが扱うデータ
* View
    * ユーザーへの出力処理
* Controller
    * 必要な処理をModelやViewに伝える
* 上記3つがそれぞれ独立して互いに連携しているのが特徴。

#### 1.3.4 Hello, world!

* 演習まで完了

#### 1.4 Gitによるバージョン管理

* 仕事をする上では欠かせないGitについてスタート

###### 1.4.1 インストールとセットアップ

* Gitにおけるコミットは、あくまでローカルマシン上での操作であること。
	* git pushコマンドで変更をリモートリポジトリにプッシュすることでリモートへ反映。

###### 1.4.2 Gitのメリット

* 読了

###### 1.4.3 Bitbucket

* GitHubで行うので軽く目を通すのみ。
* GitHubにてpush完了

###### 1.4.4 ブランチ、編集、コミット、マージ

* チュートリアルでは出てきたgit commandは業務で毎日使うコマンドが多く困ることはなかった。
    * しかし git branch -D　と　git branch -dなどの違いがわからない。(ここら辺は都度調べれば良さそう)
        * 個人的に一番いまだにわからないのが、fast-forwardとnon-fast-forward。調べたりしているがいまいち理解ができず苦手。
        * cherry-pickやrevertも好きではない、、、。

####　1.5 デプロイする

* Phusion Passenger???
* 一通りのデプロイ環境を提供するEngine YardやRails Machine???
* クラウドサービスを提供するEngine Yard CloudやHeroku??
    * Heroku以外馴染みのない言葉が多かった。

## 20200627

##### 1.5.1 Herokuのセットアップ

* herokuのコマンドが約一年ぶりで忘れていた。（現状頻繁に使うことはないので必要に応じて調べれば良さそう）
    * heroku create (Herokuサーバーにサンプルアプリケーションの実行場所を作成)
    * heroku keys:add(SSHキー)
     * SSHとかについて理解が浅い。何度か調べてはいるが口で説明ができない。

##### 1.5.2 Herokuにデプロイする (1)

* git push heroku master (Gitを使ってHerokuにリポジトリをプッシュ)
    * fetch とか mergeの理解が浅い。
        * 上記2つを同時にやるのがpullなのは理解している。。。。

##### 1.5.3 Herokuにデプロイする (2)

* 無事にデプロイ完了。
    * https://polar-falls-51413.herokuapp.com/

##### 1.5.4 Herokuコマンド

* heroku rename 新しい名前
* 演習
    * Herokuアプリのログを表示するコマンドは？
        * heroku logs

#### 1.6 最後に

* この賞で学んだこと.
    * 開発環境のセットアップやバージョン管理、本番環境へのデプロイの方法。

##### 1.6.1 本章のまとめ

 * この章で理解が不十分だと感じたこと。
    * MVCへの理解。概要はわかるが言葉では説明できない。
    * RESTはMVCよりも理解が浅い。
    * gitコマンドの理解度。
        * チュートリアルに出るコマンドは問題なく使える。
            * しかしcherry pick や revert fast-forwardやnon-fast-forward、fetch mergeの各コマンドの理解が浅い。
    * SSHあたりのセキュリティ面についての理解も自信ない。
        * SSHについては「これから学ぶmacOSターミナル」で概要は読んではいる。
            * 暗号化された通信が可能で安全なリモートログインを可能にするものであると認識している。
    * Bundlerについても詳しく知らずに使っている。
        * とりあえずbundle installやbundle updateを使っていた。

## 20200628

### 第2章 Toyアプリケーション

* scaffoldを通じてRailsアプリの構造とRailsで推奨されているRESTアーキテクチャについて学ぶ
    * RESTについて言葉で説明できないのでこの章でしっかり身につける。

#### 2.1 アプリケーションの計画

* ここは第1章でやったこととほぼ同じ。
    * routeとcontrollerを変えて、アクションの追加。

* 改めて最初にgit push する流れがイマイチなので復習

* git init　(Gitリポジトリの作成)
* git add ファイル名
* git commit -m "メッセージ"
* git remote add origin URL名
* git remote -v 上記で登録された内容の確認
* git push -u origin master
    * -uって何だろう？
        * 成功時に上流ブランチとして設定される。
            * 上流ブランチ（Upstream branch）」とは、あるローカルブランチが、履歴を追跡するように設定したリモートブランチの事を指します
                * そのブランチ上で発生したすべての更新をそのまま取り込む事を追跡するという。

* Webアプリを作る際は構造を表すためのデータモデルを最初に作成するのが通常の流れ。

##### 2.1.1 ユーザーのモデル設計

* 読了

##### 2.1.2 マイクロポストのモデル設計

* ユーザーと関連付ける必要があるので、マイクロポストの投稿者を記録するためのuser_idも追加

#### 2.2 Usersリソース

* Rails 5以前のバージョンでは、db:migrateコマンドはrailsコマンドではなくrakeコマンドが使われていました。
    * Rakeってものについてあまり知らない。

* Rails 4以前のアプリケーションでは、rakeコマンドのバージョンをGemfileで定義しているため、Bundlerのbundler execコマンドを通して実行する必要。
    * bundle exec rake db:migrate 
        * このbundle execについての理解が浅い。

##### 2.1.2 ユーザーページを探検する

* 実際にUsersリソースの挙動の確認完了。

##### 2.2.2 MVCの挙動

* RESTとは、アーキテクチャのスタイルの1つ
* RailsにおけるRESTとは？
    * アプリケーションを構成するコンポーネント (ユーザーなど) を「リソース」としてモデル化することを指す
        * リソースは、リレーショナルデータベースの作成/取得/更新/削除 (CRUD) 操作と、4つの基本的なHTTP requestメソッド (POST/GET/PATCH/DELETE) の両方に対応しています。
        * RESTfulなスタイルを採用することで、作成すべきコントローラやアクションの決定が楽になるのがメリット。

* Active Recordのおかげで便利になって、User.allやfirstを用いて簡単に操作できることは理解しているがその中身についてはよくわからない。

##### 2.2.3 Usersリソースの欠点

* 現状の状態だとvalidationなどもなく欠点が多い。

#### 2.3 Micropostsリソース

* 読了

##### 2.3.1 マイクロポストを探検する

* 実際にMicropostsリソースの挙動の確認完了。

##### 2.3.2 マイクロポストをマイクロにする

* validationの追加。
    * 基本的なvalidationに関しては理解している。

##### 2.3.3 ユーザーはたくさんマイクロポストを持っている

* 1人のユーザーに対して複数のマイクロポストがあるから、has_many
*  1つのマイクロポストは1人のユーザーにのみ属するから、belongs_to
    * 上記の関連付けの結果、User.first.micropostsなどのメソッドが使えるようになる。
        * 関連付けの結果使えるようになるメソッドの理解が浅い。(基本的なbuild等のみ)

##### 2.3.4 継承の階層

* モデルはActionController::Baseを継承することで、モデルオブジェクトはデータベースにアクセスできるようになる。
* コントローラーも同様にActionController::Baseを継承している。
    * 上記のようにActiveRecord::BaseやActionController::Baseを継承していることで、便利になっていることはわかっているが、そもそもActionController::BaseやActionController::Baseについてはよくわかっていない。


##### 2.3.5 アプリケーションをデプロイする

* デプロイ完了

#### 2.4 最後に

* MVCモデルやRESTアーキテクチャに触れることができた。

##### 2.4.1 本章のまとめ

* RailsのRESTには、標準的なURLセットと、データモデルとやりとりするためのコントローラアクションが含まれている。

* この章で理解が不十分だと感じたこと
    * Railの思想についての理解（RESTについてなど）
    * データモデル同士を関連付け
        * 関連付けを行うことで使用できるようになるメソッドへの理解が甘い。
            * 上記に関しては実際にコンソールを叩いて覚えて行きたい。
    * ActiveRecordやActionControllerへの理解。
        * 上記があることで、Railsが便利になっていることは何となく理解はしているが、深い知識がまだまだ足りない。

### 第3章 ほぼ静的なページの作成

* 静的なページの作成と自動テストのコードを書いていく。
* テストを書くメリット。
    * リファクタリングなどを行う時にテストが通ることを確認しながらできる点。

#### 3.1 セットアップ

* bundle install --without production
    * 上記のオプションをつけることで、production環境でしか使わないgemはインストールしないようにしておくことができる。
        * 一回このオプションをつけると次回以降はこのオプションは暗黙的に実行される。

* bundle updateやbundle installの明確な違いがわからない。

* 今後こまめにHerokuへデプロイする。
    * こまめにやることで、エラーなども早めに検知することができる。

#### 3.2 静的ページ

* 読了

##### 3.2.1 静的なページの生成

* rails generateってコマンドも便利だと感じていたが細かい内容についてはよくわかっていない。
    * rails generate することでいい感じに必要な複数のファイルなどを作成してくれるものだと認識して深くは理解していない。（所謂便利コマンド）

* 改めてのメモ、、、コントローラーは複数形、モデルは単数形
    * ex) usersテーブル　userモデル

    * Rubyはクラス名にキャメルケースを使う慣習
    * さらにファイル名をスネークケースで記述する慣習がある

* rails gを間違えた時の操作について理解してなかったのでメモ
    * rails generate controller StaticPages home helpを間違えたため消したい時は、、、
        * rails destroy  controller StaticPages home helpを行えはrails gで作られたファイルも削除される。
    * モデルの場合も同様で、rails generate model User name:string email:stringを消す場合は、
        *  rails destroy model User(モデル名以外は引き数はいらない)

* ページ表示までの流れ 
    * /static_pages/homeというURLにアクセスする
        * StaticPagesコントローラを参照
            * homeアクションに記述されているコード
                * そのアクションに対応するビュー出力
                    * アクション名とviewファイルの名前は対応している

* 演習　
    * 作成 rails generate controller Foo bar baz 
    * 削除 rails  destroy controller Foo bar baz

##### 3.2.2 静的なページの調整

* Viewの微調整完了

#### 3.3 テストから始める

* テスト駆動開発 (TDD)
    * ます「正しいコードがないと失敗するテスト」を書く
        * 次に正しいコードを書いてそのテストがパスするようにする。

* テストのメリットを改めて再確認する
    * 以前のバグが再発したり機能の追加/変更に副作用が生じたりすることを防止できる。
    * コードを安全にリファクタリングできる
    * アプリケーションの設計やシステムの他の部分とのインターフェイスを決めるときにも役に立つ

##### 3.3.1 最初のテスト

*  minitestの文法はあまりわからないが、RSpecで勉強したのでコードは読めそう。

##### 3.3.2 Red

* テスト駆動開発のサイクルの最初のステップは「失敗するテストを最初に書く」
    * 次にアプリケーションのコードを書いて成功させる (パスさせる）
        *  (必要なら)リファクタリングする

##### 3.3.3 Grveen

* 実際にTDDを実行。
* 実際の開発でも習慣化できると良さそう。

##### 3.3.4 Refactor

* テストをきちんと書いているからこそリファクタリングがしやすくなる。
    * テストがあるとリファクタリングした際などの他への副作用などを確認できるからである。

#### 3.4 少しだけ動的なページ

* 読了

##### 3.4.1 タイトルをテストする (Red)

* assert_selectメソッドでは、特定のHTMLタグが存在するかどうかをテスト

##### 3.4.2 タイトルを追加する (Green)

* テストが通ることを確認

##### 3.4.3 レイアウトと埋め込みRuby (Refactor)

* 同じコードを繰り返すことはDRYの原則に反する。
    * もし重複するコードを見つけたら、共通化できないか考える癖をつける。

* <%= yield %>の部分に各ページの内容をレイアウトに挿入
    * yieldは確かprocだったような、、、
        * procはいまだによくわからない。

* Asset Pipelineの仕組みについても理解が浅い、（第5章で出てくるのでそこで深める）
* CSRFなどのセキュリテイに関してもよくわかっていない。

* 演習
    * Contactページが存在することを確認するテストを書く　⇨　テストが落ちることを確認。
        * route　⇨　controller　⇨　view　の順番で修正し無事にテストが通ることを確認。

* このぐらいの小規模のものであれば特に困ることなくできそう。
    * おそらく去年はここらへんもビクビクしながらやっていたと思う、、、、笑

##### 3.4.4 ルーティングの設定

* routeを追加することによるroot_pathなどのヘルパーメソッドを確認するなら、rails／infoが便利そう？

#### 3.5 最後に
　
* https://cryptic-river-78728.herokuapp.com/ へデプロイ完了。

##### 3.5.1 本章のまとめ

* 理解が不十分と感じた点
    * yieldについての理解
        * procで出てきたのは覚えている。
    * Asset Pipelineなどの仕組み

#### 3.6 高度なセットアップ

* 読了

##### 3.6.1 minitest reporters

* 読了

##### 3.6.2 Guardによるテストの自動化

* コラム 3.4. Unixのプロセス
    * Unixなどについてのよくわかっていない。
        * ps aux などのコマンドもあまり使ったことがないので理解が追いついていない。

### 第4章 Rails風味のRuby

* 読了

#### 4.1 動機

* 読了

##### 4.1.1 組み込みヘルパー

* Railsの組み込み関数stylesheet_link_tagにもRubyの4つの概念が存在
    * Railsの組み込み関数
    * カッコを使わないメソッド呼び出し
    * シンボル
    * ハッシュ

##### 4.1.2 カスタムヘルパー

* 組み込み関数は自分でも作ることができ、それをカスタムヘルパーと呼ぶ

* helperに書くべきもの、draperに書くべきものなどの違いがわからない。
    * controllerやmodelが肥大化するのを避けるためには、適切な箇所にメソッドを書くことが不可欠。
        * しかしcontroller、model、helper、draper各所に適切に書くべきものの理解が曖昧。

#### 4.2 文字列とメソッド

* そういえばちょっとしたRubyの挙動を確認するときは、irbとかpryとか使っているが、両者の違いがわかっていない。

* Rubyの日本語の有名なリファレンス ⇨ https://docs.ruby-lang.org/ja/
    * あまりこういったリファレンスを今まで使ってなかった。

##### 4.2.1 コメント

* 読了

##### 4.2.2 文字列

* 今までは意識してなかったが、コンソールは入力したそれぞれの行を評価した結果を表示し、文字列リテラルの場合には文字列自身が表示される。

* putsの戻り値はnil
* シングルクォートは、入力した文字をエスケープせずに「そのまま」保持するときに便利。\n、\tなど

## 20200630

##### 4.2.3 オブジェクトとメッセージ受け渡し

* オブジェクトとはいつでもメッセージに応答するもの
* そもそもオブジェクト（指向）に対する理解が浅い。

##### 4.2.4 メソッドの定義

* 引数にデフォルト値を含めてると、変数に引数を渡すことも渡さないこともできます。
* Rubyのメソッドには「暗黙の戻り値がある」
    * メソッド内で最後に評価された式の値が自動的に返されること

##### 4.2.5 titleヘルパー、再び

* モジュールは、関連したメソッドをまとめる方法の１つ
    * includeでモジュールを読み込むことができる

* Rubyではincludeが必要だが、Railsでは自動的にヘルパーモジュールを読み込んでくれるので、include行をわざわざ書く必要がない。
    * ここら辺のRailsが裏側で行なってくれている便利な機能についてイマイチ理解できていない。
        * full_titleメソッドは全てのviewで使用可能

#### 4.3 他のデータ構造

* 読了

## 20200630

##### 4.3.1 配列と範囲演算子

* 配列 (array) は、特定の順序を持つ要素のリスト

* push(<<)は!がないが破壊的メソッド

* 文字列に対しても範囲オブジェクトが
    * ('a'..'e').to_a ⇨　 ["a", "b", "c", "d", "e"]

##### 4.3.2 ブロック

* ブロックは、Rubyの極めて強力な機能であり、かつわかりにくい機能
    * もっともよく使うメソッドの一つであるため、理解を深めると武器になりそう。

* Ruby共通の慣習
    * 短い1行のブロックには波カッコ使う
    * 長い1行や複数行のブロックにはdo..endを使う。
        * 上記2つは結合のレベル？に違いなどがあるらしいが、細かいことなので割愛。

*  `%w[A B C].map(&:downcase)`のような書き方も一般的。
    * 最低限読めるようにはなっておかないといけない。

##### 4.3.3 ハッシュとシンボル

* インデックスとして整数値以外のものも使える点が配列と異なる

* ハッシュは配列と似ている。
    * 1つの重要な違いとして、ハッシュでは要素の「並び順」が保証されないという点

* シンボルは、Ruby以外ではごく一部の言語にしか採用されていない特殊なデータ形式
    * Rubyからメインにプログラミングに触れたので。シンボルに対しては馴染みがあったつもりだが、シンボルは多くの言語では採用されていないとは、、、

* ハッシュの中のハッシュ
    * ちょっと苦手かも、、、配列の配列はわかっているし、それと基本的な考え方は同じ、、、だと思う。

```
 params = {}        # 'params' というハッシュを定義する ('parameters' の略)。
=> {}
 params[:user] = { name: "Michael", email: "michel@example.com" }
=> {:name=>"Michael", :email=>"michel@example.com"}
 params
=> {:user=>{:name=>"Michael", :email=>"michel@example.com"}}
 params[:user][:email]
=> "mhartl@example.com"
```

* ハッシュもeachメソッドを使える。
    * ブロックの変数はキーと値の2つになる。

##### 4.3.4 CSS、再び

* 以下のコードについて読む。

```
stylesheet_link_tag 'application', media: 'all',
                                   'data-turbolinks-track': 'reload'
```

* そもそも意識はしてなかったが、`stylesheet_link_tag`はメソッド
    * 以前教わった、`validates`もメソッド。
* 上記のstylesheet_link_tagメソッドには2つの引数がある。
    * 最初の引数である文字列は、スタイルシートへのパスを示している。
        * 次の引数であるハッシュには2つの要素があり、最初の要素はメディアタイプを示し、
            次の要素はRails 4.0で追加されたturbolinksという機能をオンにしている。

* ハッシュがメソッド呼び出しの最後の引数である場合は、波カッコを省略できる

```
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }
```

## 20200701

#### 4.3 他のデータ構造

* 改めてのメモ
    * Rubyではあらゆるものがオブジェクト
        * メソッドをまとめるのにクラス
        * 多くのオブジェクト指向言語と同じく、クラスからインスタンスが生成されることでオブジェクトが作成
        * メソッドをまとめるのにクラス

##### 4.4.1 コンストラクタ

* クラス名に対してnewメソッドを呼び出すことを名前付きコンストラクタという
    * ex) `s = String.new("foobar") `

* Hash.new はハッシュのデフォルト値を引数に取ります。(キーが存在しない場合のデフォルト値)
    * 今まで考えもしなかった新しい発見だった。

```
h = Hash.new
=> {}
h[:foo]            # 存在しないキー (:foo) の値にアクセスしてみる
=> nil
h = Hash.new(0)    # 存在しないキーのデフォルト値をnilから0にする
=> {}
h[:foo]
=> 0
```

##### 4.4.2 クラス継承

* クラスの階層について
    * ex)  String < Object < BasicObject

* Rubyにおけるすべてのクラスは最終的にスーパークラスを持たないBasicObjectクラスを継承
     * Rubyではあらゆるものがオブジェクトである"ということの技術的な意味

* selfがよくわからなくなることがある。
    * 色々な場面で出てくるselfが何を指しているのか曖昧になる時がある。

```
class Word < String             # WordクラスはStringクラスを継承する
# 文字列が回文であればtrueを返す
   def palindrome?
    self == self.reverse        # selfは文字列自身を表します
   end
end
```

##### 4.4.3 組み込みクラスの変更

* Rubyでは組み込みの基本クラスの拡張が可能
    * 既存のクラスに対して新しいメソッドの追加やオーバーライドができる。

* blank?もRailsがRubyに追加した具体例の一つ

##### 4.4.4 コントローラクラス

* Railsのコントローラーも同じように階層的に継承がある。
    * StaticPagesController < ApplicationController < ActionController::Base 
                   < ActionController::Metal < AbstractController::Base < Object
                   
* 重要な点 
    * Railsのアクションには戻り値がない。（返される値は重要ではない）
        * home アクションはWebページを表示するためのものであり、値を返すためのものではなかった。
            * そして、第3章では一度もStaticPagesController.newを実行しませんでした。しかし上手く動いている。
                * RailsはRubyで書かれているが、既にRubyとは別物。Railsのクラスは、普通のRubyオブジェクトと同様に振る舞うものもありますが、多くのクラスにはRailsの魔法が振りかけられている。
                    そのためRailsはRubyとは切り離して学習する必要があります。

* 言われてみると、確かに〇〇.newとかしてなかった。

## 20200702

##### 4.4.5 ユーザークラス

```
class User
  attr_accessor :name, :email

  def initialize(attributes = {}) # ← ここの書き方に慣れない   initialize(name, email) ← こっちば馴染みある
    @name  = attributes[:name]                                  @name = name
    @email = attributes[:email]                                 @email = email
  end     

  def formatted_email
    "#{@name} <#{@email}>"
  end
end
```

* initialize(attributes = {})の書き方に馴染みがないと感じた。
    * initialize(name, email) の方の書き方なら理解は出来ていると思っている。。

* マスアサインメント (mass assignment) と呼ばれる技法
    * 名前に馴染みなかった。。。

## 20200703

#### 4.5 最後に

* GitHubへpush済み

##### 4.5.1 本章のまとめ

* Rubyの組み込みクラスには配列、範囲、ハッシュなどがある
    * 他の組み込みクラスについても軽く触れてみよう

* Rubyの世界では、すべてがオブジェクト
    * オブジェクト指向というものに親しみを持てるように再度「オブジェクト指向」というもにについて知っておきたい

* 本章で苦手だと感じたこと
    * ハッシュに対しての理解。特に引数にハッシュが来る場合
    * selfについて（インスタンスメソッド内のselfやクラスメソッド内のクラスなどについての区別）
    * ブロックについてももう少し理解を深めると武器になるはず
        * each、map、selectなどは理解しているとは思う。

    * Railsに対するコードに新たな発見があった。
        * validatesやstylesheet_link_tagってものがメソッドということを意識してなかった。

### 第5章 レイアウトを作成する

* Bootstrapフレームワークを組み込みデザインを加える
* パーシャル、Railsのルーティング、Asset Pipelineについて触れる
    * 上記３つ規則などを改めて理解する。
    * 特にAsset Pipelineはイマイチ理解していないので、この機会にしっかり覚える。
* 統合テスト (Integration Test)」についても学ぶ

#### 5.1 構造を追加する

* Bootstrapを使ってデザインを当てていく
    * デザインについてはコピペで進めていくので良さそう

## 20200704

##### 5.1.1 ナビゲーション

* HTML5は比較的新しく、一部のブラウザ (特に旧式のInternet Explorer) ではHTML5のサポートが不完全である場合がある。
    * そのため、以下のようなJavaScriptのコード (通称: HTML5 shim (or shiv))を使ってこの問題を回避する

```
<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js">
  </script>
<![endif]-->
```

* `<!--[if lt IE 9]>`の意味
    * IE) のバージョンが9より小さい場合 (if lt IE 9) にのみ、囲まれている行を実行するという意味
        * Railsのコードではなく、Internet Explorerで特別にサポートされているコメント
            * その結果、Firefox、Chromeに影響を与えずに済むようになっている。

* Railsヘルパーのlink_toについて改めて学習
    * link_toの第1引数はリンクテキスト、第2引数はURL, 第3引数はオプションハッシュ
        * 第3引数のオプションハッシュは必須ではない
            * 上記については覚える必要はなく、都度調べれば解決

* curlコマンドについての理解。
    * 手軽にHTTPリクエストができるコマンド

* 画像を表示
    * 生成されたHTMLを確認するとsrc属性にはimagesィレクトリ名が含まれていない
        * assetsディレクトリ内の他のディレクトリ (imagesやjavascripts、stylesheetsなど) も同様
            * 高速化のための仕組み
                * こういった仕組みについて理解が浅い

* 演習
    * 画像の取得 curl -OL cdn.learnenough.com/kitten.jpg
    * mvコマンドを使って移動 mv kitten.jpg app/assets/images

##### 5.1.2 BootstrapとカスタムCSS

* Bootstrapをインストール
    * あまり使わない技術なので、ここらへんはささっと！

* app/assets/stylesheets/はAsset Pipelineの一部

##### 5.1.3 パーシャル (partial)

* Railsヘルパーであるrenderを使う
    * `<%= render 'layouts/shim' %>`でapp/views/layouts/_shim.html.erbを探す
        * ファイル名 _shim.html.erb の先頭にあるアンダースコアがポイント
            * renderについての理解を深めたい。⇨ Railsガイドなどをみる

#### 5.2 Sassとアセットパイプライン

* 最近のRailsに追加された機能の中で最も特筆すべき機能の１つがCSS、JavaScript、画像などの静的コンテンツの生産性と管理を大幅に強化するAsset Pipeline
    * ここでAsset Pipelineの理解を深める

##### 5.2.1 アセットパイプライン

* 3つの主要な機能が理解の対象になる
    * それがアセットディレクトリ、マニフェストファイル、プリプロセッサエンジン
        * 上記のようなものは今までおろそかにしていたので、ここで理解を深め苦手意識を無くしたい

* アセットディレクトリ
    * Railsのアセットパイプラインでは、静的ファイルを目的別に分類する、標準的な３つのディレクトリが使われている
        * app/assets: 現在のアプリケーション固有のアセット
        * lib/assets: あなたの開発チームによって作成されたライブラリ用のアセット
        * vendor/assets: サードパーティのアセット 
            * 上記のディレクトリにはそれぞれのアセットクラス用のサブディレクトリがある。
                * app/assetsの場合、次のような画像用、JavaScript用、CSS用のサブディレクトリがある

* マニフェストファイル
    * 静的ファイル (アセット) を上記の場所へそれぞれ配置すれば、マニフェストファイルを使って、それらをどのように1つのファイルにまとめるのかをRailsに指示することができる。
        * 実際にアセットをまとめる処理を行うのはSprocketsというgem。
            * マニフェストファイルはCSSとJavaScriptには適用されますが、画像ファイルには適用されない
                * このようなRailsの裏側の仕組み？というものを理解していない気がする。
                    * なんとなく「便利にうまいことしてくれている」という感じで流していた
    
    * アプリケーションのCSS用マニフェストファイルの例
        * ` *= require_tree .`はapp/assets/stylesheetsディレクトリ (サブディレクトリを含む) 中のすべてのCSSファイルが、アプリケーションCSSに含まれるようにしている。
        * ` *= require_self`で、pplication.css自身もその対象に含めている。

* プリプロセッサエンジン
    * 必要なアセットをディレクトリに配置してまとめた後、Railsはさまざまなプリプロセッサエンジンを介してそれらを実行し、ブラウザに配信できるようにそれらをマニフェストファイルを用いて結合し、サイトテンプレート用に準備する。
        * どのプリプロセッサを使うのかをファイルの拡張子を使って判断する
            * .scss, .coffee, .erbなど。
    * プリプロセッサエンジンは、繋げて実行する (chain) ことができる。
        * ex) foobar.js.erb.coffee
            * 上の拡張子の場合は、CoffeeScriptとERbの両方で実行されます (コードは右から左へと実行されますので、この例ではCoffeeScriptが最初に実行される

* 本番環境での効率性
    * Asset Pipelineの最大のメリットの1つ
        * 本番のアプリケーションで効率的になるように最適化されたアセットも自動的に生成されること
            * 今までは、CSSとJavaScriptを整理するために、機能を個別のファイルに分割し、(インデントを多用して) 読みやすいフォーマットに整えていた。
                * 上記の方法だと本番環境には非効率で、ページの読み込みが遅くなりユーザーが離れていく原因となった。
                    * しかし、Asset Pipelineを使うことで全てのスタイルシートを1つのCSSファイルやJSファイルにまとめてくれ、さらには不要な空白やインデントを削除してくれるので、結果としてファイルサイズを最小化してくれる。
        
##### 5.2.2 素晴らしい構文を備えたスタイルシート

* Sass は、スタイルシートを記述するための言語
    * cssの強化版
        * 重要な機能は変数と機能
* ここは簡単に読む程度に留めておく。

#### 5.3 レイアウトのリンク

* `#`で代用していたリンクを書き換える
    * `<a href="/static_pages/about">About</a>`のように書けるが、Railsは名前つきルートを使うのが慣習
        * `<%= link_to "About", about_path %>`のように書く
            * このように書くことで、about_pathの定義を変えればabout_pathが使われているすべてのURLを変更できるため柔軟性が高くなる

##### 5.3.1 Contactページ

* contactページの追加

##### 5.3.2 RailsのルートURL

* rootメソッドを使ってルートURL "/" をコントローラーのアクションに紐付けていた
    * rootもメソッドなのか、、、、！
        * ルートURLを定義すると、root_pathやroot_urlといったメソッドを通してURLを参照することができるようになる
            * 前者はルートURL以下の文字列を、後者は完全なURLの文字列
            * 基本的には_path書式を使い、リダイレクトの場合のみ_url書式を使うようにする
                * HTTPの標準としては、リダイレクトのときに完全なURLが要求されるため(ただし、ほとんどのブラウザではどちらの方法も機能する)

```
root_path -> '/'
root_url  -> 'http://www.example.com/'
```

* 演習
    * 名前付きルートの変更には`as`が使える
        * `get '/help', to: 'static_pages#help', as: 'helf'`とすると、、、、
        * help_pathがhelf_pathになる

##### 5.3.3 名前付きルート

* 完了

##### 5.3.4 リンクのテスト

* 統合テストを使うと、アプリケーションの動作を端から端まで (end-to-end) シミュレートしてテストすることができる
    * テスト作成用のコマンド
        * `rails generate integration_test site_layout`

* 今回のテストの流れ
    * ルートURL (Homeページ) にGETリクエストを送る
    * 正しいページテンプレートが描画されているかどうか確かめる
    * Home、Help、About、Contactの各ページへのリンクが正しく動くか確かめる

#### 5.4 ユーザー登録: 最初のステップ

* ユーザー登録ページへのルーティングを作成

##### 5.4.1 Usersコントローラ

* Usersコントローラを作成
    * 前回同様`rails g`コマンドを使って作成
        * 最初に作られるpathをget  '/signup',  to: 'users#new’に変更する

##### 5.4.2 ユーザー登録用URL

* get ’/signup’と記述したことでsignup_pathという名前付きルートができる
    * 名前つきルートなども基本は理解しているが、たまにasオプションなどを見ると??となってしまう

#### 5.5 最後に

* git push 完了
* Herokuへもデプロイ完了

##### 5.5.1 本章のまとめ

* Railsのパーシャル
* SassとAsset Pipelineは、(開発効率のために切り分けられた) CSSの冗長な部分を圧縮し、本番環境に最適化した結果を出力する
* Railsのルーティングでは自由にルールを定義することができ、また、その際に名前付きルートも使えるようになる
* 統合テストは、ブラウザによるページ間の遷移を効率的にシュミレーションできる

* 本章で苦手だと感じたこと
    * routeへの深い理解
        * 基本的な知識はあるが、asオプションなどを使ってこなかったことによるオプションへの理解
    * Asset Pipelineの仕組み
        * 今回の5章を通じて少しは理解できがた、説明できるか？といえばまだ出来なさそう
    * SassやCSSに対する深い理解
        * 今回の学習のメインではないので割愛しても良さそう
    * root_pathやroot_urlの使い分けなど

### 第6章 ユーザーのモデルを作成する

* ユーザー用のデータモデルの作成とデータを保存する方法について学ぶ

#### 6.1 Userモデル

* 今のままでは新しいユーザーの情報を受け取っても保存する場所がない
    * なので、情報を保存するためのデータ構造を作成する（モデル）

* Railsでは、データベースを使ってデータを長期間保存する
    * データベースとやりとりをするデフォルトのRailsライブラリはActive Record
        * Active Recordは、データオブジェクトの作成/保存/検索のためのメソッドを持っている
    
* Railsにはマイグレーション (Migration) という機能がある
    * データの定義をRubyで記述することができる

##### 6.1.1 データベースの移行

* Railsでユーザーをモデリングするときは、属性を明示的に識別する必要がない
    * Railsはデータを保存する際にデフォルトでリレーショナルデータベース使う

* コントローラ名には複数形を使い、モデル名には単数形を用いる
* rails g modelで作成
* 間違えても rails destroy model で簡単に削除可能

* rails g modelの結果、マイグレーションファイルが作成される。
    * モデル名は単数形 (User) ですが、テーブル名は複数形 (users)
        * マイグレーションの細かいカスタマイズ（index）の追加などはあまり活用できていない。
            * 現状だとファイルが作成されているだけなので、マイグレーションの適用するために`rails db:migrate`のコマンドを打つ

* schema.rbとは
    * データベースの構造を追跡するためのもの。
        * このファイルを見れば現在のdbの構造を知ることができる

##### 6.1.2 modelファイル

* Userモデルは自動的にActiveRecord::Baseを継承しているので、最初から様々な機能を持っている
    * コンソールでnewなどを使用できることを確認

##### 6.1.3 ユーザーオブジェクトを作成する

* rails console --sandboxって使い方をほぼ忘れかけていた
* オブジェクトが有効か
    * `.valid?`を使う
    * User.createは、trueかfalseを返す代わりに、ユーザーオブジェクト自身を返す
        * つまり変数にも代入可能

##### 6.1.4 ユーザーオブジェクトを検索する

* Active Recordには、オブジェクトを検索するための方法がいくつもある
    * findではidで検索
    * find_byはid以外の属性でも検索できる
        * 値がないときはnil findは例外が発生する
            * ここら辺の使い分けって難しく感じる
    * ActiveRecord::Relationは各オブジェクトを配列として効率的にまとめてくれるクラス

##### 6.1.5 ユーザーオブジェクトを更新する

* update_attributesでも更新ができる
    * 属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行う
        * しかし１でも検証に失敗するとupdate_attributesの呼び出しは失敗する
* update_attributeには、検証を回避するといった効果がある

#### 6.2 ユーザーを検証する

* Active Record では検証 (Validation) という機能を通して、制約を追加することができる
* 検証に引っかかった場合にエラーメッセージを表示する

##### 6.2.1 有効性を検証する

* モデルのバリデーション機能は、テスト駆動開発とまさにピッタシの機能
    * バリデーション機能は強力だが、うまく動いているか自信を持つのが難しい
        * そこでテストの出番

* 具体的なテスト方法
    * まず有効なモデルのオブジェクトを作成
    * その属性のうちの1つを有効でない属性に意図的に変更
    * バリデーションで失敗するかどうかをテスト
    * 念のため、最初に作成時の状態に対してもテストを書いておき、最初のモデルが有効であるかどうかも確認

##### 6.2.2 存在性を検証する

* Presenceを用いて検証する
    * ここではユーザーがデータベースに保存される前にnameとemailフィールドの両方が存在することを保証

* 改めて、、、、validatesは単なるメソッド

* 検証に失敗した際には、errorsオブジェクトを使って確認すれば便利

```
user.errors.full_messages
=> ["Name can't be blank"]

 u.errors.messages
=> {:name=>["can't be blank"], :email=>["can't be blank"]}

u.errors[:email]
=> ["can't be blank"
```

##### 6.2.3 長さを検証する

* ユーザーの名前はサンプルWebサイトに表示されるものなので、名前の長さにも制限を与える必要がある
    * lenghtを用いる

* lengthの検証で引っかかった場合のエラーメッセージ

```
user.errors.full_messages
=> ["Name is too long (maximum is 50 characters)", "Email is too long (maximum is 255 characters)"]
```

##### 6.2.4 フォーマットを検証する

* email属性の場合は、有効なメールアドレスかどうかを判定するために、もっと厳重な要求を満たさなければならない
    * メールアドレスのパターンに合っているかを検証する必要がある
        * メールアドレスのバリデーションは扱いが難しく、エラーが発生しやすい部分なので、有効なメールアドレスと無効なメールアドレスをいくつか用意して、バリデーション内のエラーを検知していく
    * メールアドレスのフォーマットを検証するためには、次のようにformatというオプションを使う

* 正規表現は苦手で本当の最小限のみで終えていた
    * grepなどでも正規表現は便利なので、覚えていく必要あり。

##### 6.2.5 一意性を検証する

* 一意性を保つためのメソッドがvalidatesのuniqueオプション

* 今回の一意性を確認するテストは少し今までとやり方が異なる。
    * 一意性のテストのためには実際にデータベースにレコードを登録する必要あり

```
test "email addresses should be unique" do
  duplicate_user = @user.dup  # userの複製
  @user.save 1つ目のuserをデータベースへ登録
  assert_not duplicate_user.valid? 上記で同じ値をもつデータが登録されているので、ここの検証でダメとなる
end
```

* ちなみにメールアドレスは大文字小文字を区別しない
    * つまり、、、foo@bar.comはFOO@BAR.COMやFoO@BAr.coMと書いても扱いは同じ
        * なので、メールアドレスの検証ではこのような場合も考慮する必要がある
            * : { case_sensitive: false }のオプションをつける
                * 実際にこういった実装をする時につい抜けてしまいそう、、、。

```
test "email addresses should be unique" do
  duplicate_user = @user.dup
  duplicate_user.email = @user.email.upcase
  @user.save
  assert_not duplicate_user.valid?
end
```

* ここで問題がある
    * Active Recordはデータベースのレベルでは一意性を保証していないという問題
        * 仮に登録の際に、素早く連続でクリックされると同じ内容で登録できてしまうケースが発生する
            * 解決するためにはデータベースレベルでも一意性を強制する
                * 具体的にはそのカラムにインデックスを追加する
                    * インデックスには本でいう索引のようなもので検索を効率的に行なってくれる

*  rails generate migration でマイグレーションファイルを直接作成
    * インデックス自体は一意性を強制しない
        * オプションでunique: trueを指定することで強制

```
class AddIndexToUsersEmail < ActiveRecord::Migration[5.1]
  def change
    add_index :users, :email, unique: true
  end
end
```

* fixturesとはテストDB用のサンプルデータが含まれている場所

* 今回のアプリではFoo@ExAMPle.Comとfoo@example.comが同一であると解釈されるべき
    * しかしデータベース上では、別々のものと解釈されてしまう
        * なので、データベースへ保存される直前にすべての文字列を小文字に変換することで対応
            * そこでコールバックの出番
                * 正直、before_actiongぐらいしか使って来なかった

* ` before_save { self.email = email.downcase }`
    * ここでもselfが、、、
        * このselfはユーザーである
            * 右辺のselfは省略可能

## 20200705

#### 6.3 セキュアなパスワードを追加する

* 安全なパスワードを作成するために、ユーザが入力したデータをそのままではなく、ハッシュ化してDBに保存する
    * Rubyのハッシュ化とは別物

* ユーザーの認証は、、、、 
    * パスワードの送信、ハッシュ化、データベース内のハッシュ化された値との比較という流れ
        * ハッシュ化されたパスワード同士を比較していることがポイント

##### 6.3.1 ハッシュ化されたパスワード

* `has_secure_password`というRailsのメソッドを呼び出すだけで完了
    * このメソッドを追加すると、、、
        * データベース内のpassword_digestという属性に保存できる
        * 2つのペアの仮想的な属性 (passwordとpassword_confirmation) が使えるようになる
            * 存在性と値が一致するかどうかのバリデーションも追加される
        * authenticateメソッドが使えるようになる (引数の文字列がパスワードと一致するとUserオブジェクトを、間違っているとfalseを返すメソッド)
    * has_secure_password機能を使うためには条件がある
        * モデル内にpassword_digestという属性が含まれていること
        * 最先端のハッシュ関数であるbcryptが必要

* カラム追加用のマイグレーション
    * rails generate migration add_password_digest_to_users password_digest:string
        * 末尾にto_usersをつけることでusersテーブルにカラムを追加するマイグレーションファイルをRailsが自動的に作成してくれる

##### 6.3.2 ユーザーがセキュアなパスワードを持っている

* 演習

    * userオブジェクトに有効な名前とメールアドレスを与えても、valid?で失敗してしまう際のエラーメッセージ

```
u.errors.full_messages
=> ["Password can't be blank"]
```

##### 6.3.3 パスワードの最小文字数

* has_secure_passwordメソッドは存在性のバリデーションもしてくれる
    * しかし新しくレコードが追加されたときだけに適用される
        * ユーザーが ' ' (6文字分の空白スペース) といった文字列をパスワード欄に入力して更新しようとすると、バリデーションが適用されずに更新されてしまう

* 演習

    * passwordが短い場合のメッセージ

```
u.errors.full_messages
=> ["Password is too short (minimum is 6 characters)"]
```

##### 6.3.4 ユーザーの作成と認証

* コンソールで実際に手動でユーザーを作成する

* 実際に作ったユーザーが￥でpassowrd_digestやauthenticateを使ってみる
    * 間違ったパスワードを渡すとfalse
    * 正しいパスワードを渡すとユーザーオブジェクトを返すようになる

```
user = User.find_by(email: "mhartl@example.com")
 User Load (0.2ms)  SELECT  "users".* FROM "users" WHERE "users"."email" = ? LIMIT ?  [["email", "mhartl@example.com"], ["LIMIT", 1]]

user.password_digest
=> "$2a$12$X0z1i2xymGNRV/B81E7vFej33s/QXPlWOna4dI0dcczUmSjfXKeHi"

user.authenticate("foobaz")
=>false

user.authenticate("foobar")
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2020-07-04 21:44:40", updated_at: "2020-07-04 21:44:40", password_digest: "$2a$12$X0z1i2xymGNRV/B81E7vFej33s/QXPlWOna4dI0dccz...">
```

#### 6.4 最後に

* git push済み

##### 6.4.1 本章のまとめ

* 本章を通じて苦手だと感じた箇所
    * 細かいマイグレーションの使い方
        * 実際の現場では、rails db:migrateしたらrollbackもできることを確認するなどの細かい部分の理解が浅い
        * マイグレーションファイルを実際にあまり自分でカスタマイズしたことがないので、Railsガイドを見ながらやる必要あり
    * 正規表現
        * 本当の基礎しかわかっていない
            * Rails以外でも役立つのでもう少し理解を深める
    * DBに対する知見
        * ex) インデックスを追加することで検索効率が向上するなど
    * Active::Recordのメソッドの細かい違い
        * ex) findとfind_byの使い分けなど、、、、(nilか例外が変えるかは理解している)
        * ex2) update_attributesとupdate_attributeなど（ここに関しては今回学んだ）

### 第7章 ユーザー登録

* 読了

#### 7.1 ユーザーを表示する

* 読了

##### 7.1.1 デバッグとRails環境

* ここからは動的なページを作る（ユーザー情報に基づいて表示が変わる）

* デバッグ情報を追加
    * `<%= debug(params) if Rails.env.development? %>`を追加
        * デバッグ情報はRailsの3つのデフォルト環境のうち、開発環境 (development) だけで表示されるようになる
            * envってものの理解も浅い。環境変数が、、、とかは少し理解はしているが、、、、。

* Railsの3つの環境
    * テスト環境 (test)
    * 開発環境 (development)
        * Rails コンソールの環境はdevelopment(基本的にはオプションで指定しない限りdevelopmentが使われる)
    * 本番環境 (production) 


    * RailsにはRailsというオブジェクトがあり、それには環境の論理値 (boolean) を取るenvという属性がある

    * アプリケーションを本番環境で実行する場合、本番のデータベースが利用できないとアプリケーションを実行できない
        * なので、rails db:migrate RAILS_ENV=productionと明示して本番環境で実行しないといけない

##### 7.1.2 Usersリソース

* ユーザー情報をWebアプリケーション上に表示する
    * RESTアーキテクチャの習慣に従う
        * データの作成、表示、更新、削除をリソース (Resources) として扱う
        * HTTP標準には、これらに対応する４つの基本操作 (POST、GET、PATCH、DELETE) が定義されているので、これらの基本操作を各アクションに割り当てていく

* `resources :users`を追加することで、RESTfulなUsersリソースで必要となるすべてのアクションが利用できるようになる

* paramsってすごい便利だが、その詳細についてはあまり知らないかも
    * paramsってものがどんな情報を持ってくるかを調べる
    * params[:id]は文字列型の "1"
    * findメソッドでは自動的に整数型に変換される

##### 7.1.3 debuggerメソッド

* byebug gemを使ってシステムの状態を調査することはエラーの追跡に便利
    * debuggerを仕込んで学習も良さそう

##### 7.1.4 Gravatar画像とサイドバー

* デフォルトでは、ヘルパーファイルで定義されているメソッドは自動的にすべてのビューで利用できる
    * ヘルパーメソッドはレシーバがいらない

#### 7.2 ユーザー登録フォーム

* 読了

##### 7.2.1 form_forを使用する

* ユーザー登録に欠かせない情報を入力するためのformを作成
    * form_forヘルパーメソッドを使う(今回はform_withではない)

##### 7.2.2 フォームHTML

* form_forのブロック変数fがしていること
    * fオブジェクトは、HTMLフォーム要素 (テキストフィールド、ラジオボタン、パスワードフィールドなど) に対応するメソッドが呼び出されると、@userの属性を設定するために特別に設計されたHTMLを返す
         * `<%= f.text_field :name %>`とすることで、Userモデルのname属性を設定するHTMLを返す
            * よってUserモデルにない属性を指定するとエラーになる

* Railsはformタグを作成するときに@userオブジェクトを使う
    * @userは新しいユーザーなので、 Railsはpostメソッドを使ってフォームを構築する

#### 7.3 ユーザー登録失敗

* 読了

##### 7.3.1 正しいフォーム

* 以下のハッシュはUsersコントローラにparamsとして渡されている
    * params[:id]とか無意識に使っているが、渡している値などをしっかり見る必要がある
    * paramsハッシュには各リクエストの情報が含まれる
    * ハッシュのキーはデバッグ情報では文字列となっていますが、Railsは文字列ではなく、params[:user]のように「シンボル」としてUsersコントローラに渡している点に注意

```
"user" => { "name" => "Foo Bar",
            "email" => "foo@invalid",
            "password" => "[FILTERED]",
            "password_confirmation" => "[FILTERED]"
          }

@user = User.new(params[:user])は以下と同じ意味

@user = User.new(name: "Foo Bar", email: "foo@invalid",
                 password: "foo", password_confirmation: "bar")
```

##### 7.3.2 Strong Parameters

* `@user = User.new(params[:user]) `の実装はセキュリティ的な面で危険
    * paramsハッシュ全体を初期化するという行為が危険
        * params[:user]という中にadminなどの値を紛れ込ませて渡してしまうことも可能である
            * そこでstrong parameterの出番
            * `params.require(:user).permit(:name, :email, :password, :password_confirmation)`
                * 上記の戻り値はハッシュ

##### 7.3.3 エラーメッセージ

* Railsは、エラーメッセージをUserモデルの検証時に自動的に生成してくれる
    * errors.full_messagesオブジェクトは、 エラーメッセージの配列をもつ

```
user.errors.full_messages
=> ["Email is invalid", "Password is too short (minimum is 6 characters)"]
```

* エラーメッセージをブラウザで表示するには、ユーザーのnewページでエラーメッセージのパーシャル (partial) を出力
    * 'shared/error_messages'というパーシャルをrender
        * Rails全般の慣習として、複数のビューで使われるパーシャルは専用のディレクトリ「shared」によく置かれる
            * この「Railsの慣習」というものをもっと理解いきたい
                * Railsの思想やルールを深く理解することを意識する

* Railsは、無効な内容の送信によって元のページに戻されると、CSSクラスfield_with_errorsを持ったdivタグでエラー箇所を自動的に囲む

* 現在のコードだと、、、
    * presence: trueによるバリデーションも、has_secure_passwordによるバリデーションも空のパスワード (nil) を検知する
        * つまり、エラーで同じメッセージが2つ出てしまう
            * 上記に関しては後ほど解決する（allow_nil: trueを使う）

* 演習
    * 未送信のユーザー登録フォームのURLと、送信済みのユーザー登録フォームのURLを比べてると違う
        * http://localhost:3000/signup
        * http://localhost:3000/users
            * formのactionの指定が/usersへリクエストが送られるため

##### 7.3.4 失敗時のテスト

* 今回のテストでは登録ボタンを押した時にユーザーが作成されないことを確認するテスト
    * ユーザーのカウントで確認する

* テストの中身
    * form送信をテストするためには、 users_pathに対してPOSTリクエストを送信
        * postメソッドを使って実現
            * 以下のテストはユーザ数を覚えた後にデータを投稿してみて、ユーザ数が変わらないかどうかを検証

```
assert_no_difference 'User.count' do
  post users_path, params: { user: { name:  "",
                                     email: "user@invalid",
                                     password:              "foo",
                                     password_confirmation: "bar" } }
end
```

#### 7.4 ユーザー登録成功

* 新規ユーザーを実際にデータベースに保存できるようにする

##### 7.4.1 登録フォームの完成

* Railsの一般的な慣習にしたがって、ユーザー登録に成功した場合はページを描画せずに別のページにリダイレクトする
    * 新しく作成されたユーザーのプロフィールページにリダイレクト(users/:id/)
        * `redirect_to @user`と書くが、これは`redirect_to user_url(@user)`と同じ
            * ここら辺のRailsの便利機能をしっかり理解したい

##### 7.4.2 flash

* flashという特殊な変数を使う
    * 変数はハッシュのように使う
        * 成功時には:successというキーにメッセージを代入

* 演習
    * 文字列内の式展開でシンボルを呼び出してみると文字列になる。
        * 普段どんな値が返ってくるかを意識してなかったが新しい発見
    
```
"#{:success}"
=> "success"
```

##### 7.4.3 実際のユーザー登録

* 読了

##### 7.4.4 成功時のテスト

* assert_differenceというメソッドを使ってテスト
    * ここら辺はminitestなので深追いはせずに「何をやっているか」の理解に留める

*  ヘルパーのcontent_tagを今まであまり使ってこなかった
    * 使う際に引数に与えるものなどを調べれば良さそう

#### 7.5 プロのデプロイ

* ユーザー登録をセキュアにするために、本番用のアプリケーションに重要な機能を追加

##### 7.5.1 本番環境でのSSL

* ユーザー登録フォームで送信すると、名前やメールアドレス、パスワードといったデータがネットワーク越しに流されていく
    * このようなネットワークに流れるデータは途中で捕捉できるため、扱いには注意が必要
        * SSLを使い修正していく
            * SSLはローカルのサーバーからネットワークに流れる前に、大事な情報を暗号化する技術

* SSLの有効化
    * SSLを有効化するのも簡単。production.rbという本番環境の設定ファイルの1行を修正するだけ
        * 具体的には、configに「本番環境ではSSLを使うようにする」という設定をするだけ

##### 7.5.2 本番環境用のWebサーバー

* 読了

#### 7.6 最後に

* 読了

##### 7.6.1 本章のまとめ

* debugメソッドを使うことで、役立つデバッグ情報を表示
* Railsには標準で3つ環境が備わっており、それぞれ開発環境 (development)、テスト環境 (test)、本番環境 (production)

* この章で苦手だと感じたこと
    * paramsが渡してくるデータを今まで意識したことなかった
        * なんとなくparams[:id]ってやっておけば良い感じになっていた
         * paramsハッシュには各リクエストの情報が含まれる
    * byebugを使いこなすと便利かも？
        * Rails.loggerやinspectで代用できている
    * .envというものの理解
    * form_forやform_withの使いわけ
        * 現在のRailsのバージョンではform_withが推奨されてはいる
    * SSLなどといったWebの知見が不足

## 20200706

### 第8章 基本的なログイン機構

* ここからログインとログアウト
    * セッションやクッキーなど曖昧なところが多いので、じっくり進める

* ログインの基本的な仕組みとは、ブラウザがログインしている状態を保持し、ユーザーによってブラウザが閉じられたら状態を破棄するといった仕組み
    * この章ではブラウザを閉じるとログインしたユーザー情報を強制的に忘れるようになっている

* 制限や制御の仕組みを認可モデルと呼ぶ
    * ex) ログイン済みかどうかでヘッダー部分を切り替えるなど

#### 8.1 セッション

* HTTPはステートレスなプロトコル
    * つまり状態を保持しない
        * HTTPのリクエスト１つ１つは、それより前のリクエストの情報をまったく利用できない
            * ブラウザのあるページから別のページに移動したときに、ユーザーのIDを保持しておく手段がHTTPプロトコル内にはまったくない

* ユーザーログインの必要なWebアプリケーションではどうする？
    * セッションと呼ばれる半永続的な接続をコンピュータ間 (ユーザーのパソコンのWebブラウザとRailsサーバーなど) に別途設定
        * セッションはHTTPプロトコルと階層が異なる(上の階層にある)
            * そのためHTTPの特性とは別に接続を確保できる

* Railsでセッションを実装する方法
    * cookiesを使う
        * cookiesとは、ユーザーのブラウザに保存される小さなテキストデータ
            * cookiesは、あるページから別のページに移動した時にも破棄されないので、ここにユーザーIDなどの情報を保存できる
                * sessionというRailsのメソッドを使って一時セッションを作成(この一時セッションは、ブラウザを閉じると自動的に終了)

* UsersリソースとSessionリソースの違い
    * UsersリソースではバックエンドでUserモデルを介してデータベース上の永続的データにアクセス
    * Sessionリソースでは代わりにcookiesを保存場所として使う
        * ログインの仕組みの大半は、cookiesを使った認証メカニズムによって構築されている

##### 8.1.1 Sessionsコントローラ

* ログインとログアウトの要素を、Sessionsコントローラの特定のRESTアクションにそれぞれ対応付ける
    * ログインのフォームはnewアクション
    * createアクションにPOSTリクエストを送信すると、実際にログイン
    * destroyアクションにDELETEリクエストを送信すると、ログアウト

* 演習
    * rails routes | grep sessionsを使えばsessionsの名前つきルートを調べられる

## 20200707

##### 8.1.2 ログインフォーム

* ログインフォームとユーザー登録フォームにはほとんど同じ
    * 違いは、4つあったフィールドがEmailとPasswordの2つに減っていることだけ

* 今まではエラーメッセージを出力する場合、Active Recordによって自動生成されるメッセージを使っていた
    * しかし今回はActive Recordを継承しているわけでない
        * つまり自分でエラーメッセージを作成する必要あり

* セッションフォームとユーザー登録フォームの最大の違い
     * セッションにはSessionモデルがない
     * @userのようなインスタンス変数に相当するものがない
        * セッションの場合はリソースの名前とそれに対応するURLを具体的に指定する必要がある

```
前回の@userのケース
form_for(@user)

今回のケース
form_for(:session, url: login_path)
```

* 上記の結果、paramsハッシュに入る値が、メールアドレスとパスワードのフィールドにそれぞれ対応したparams[:session][:email]とparams[:session][:password]になる

```
実際にparamsの値を確認
"session"=>{"email"=>"hoge@example.com", "password"=>"hogehoge"}, "commit"=>"Log in", "controller"=>"sessions", "action"=>"create"}
```

##### 8.1.3 ユーザーの検索と認証

* formから送られてくるparamsの中身は`{ session: { password: "foobar", email: "user@example.com" } }`
    * つまり`params[:session][:email]`のようにデータにアクセスできる
         * 以下のように実装する

```
まずはメールアドレスからユーザー情報を持ってくる
そして、そのユーザーのパスワードが正しいかをauthenticateメソッドを用いて検索している
user = User.find_by(email: params[:session][:email].downcase) # find_byはid以外のユニークは値で検索できる
user && user.authenticate(params[:session][:password])
```

##### 8.1.4 フラッシュメッセージを表示する

* sessionはuserと違いActive Recordを継承していない
    * そのためログインに失敗したときには代わりにフラッシュメッセージを表示する

```
#現在の状態は正しくない
#renderとredirect_toは違うためである。.nowを追加で解決する
flash[:danger] = 'Invalid email/password combination' 
render 'new'
```

## 20200708

##### 8.1.5 フラッシュのテスト

* テストの流れ
    * ログイン用のパスを開く
    * 新しいセッションのフォームが正しく表示されたことを確認
    * わざと無効なparamsハッシュを使ってセッション用パスにPOSTする
    * 新しいセッションのフォームが再度表示され、フラッシュメッセージが追加されることを確認
    * 別のページへ移動する
    * そのページでフラッシュメッセージが表示されていないことを確認する

* `flash.now`のメッセージはその後リクエストが発生したときに消滅
    * 基本、renderの時は`flash.now`をつけると良さそう

#### 8.2 ログイン

* cookiesを使った一時セッションでユーザーをログインできるようにする
    * このcookieはブラウザを閉じると自動的に有効期限が切れる
* セッションを実装するには、様々なコントローラやビューで多くの数のメソッドを定義する必要がある
    * しかしRubyのモジュール機能を使うと、そうしたメソッドを一箇所に置くだけで済む
        * セッション用ヘルパーモジュールもコントローラーを作成した時に作られている
            * Railsのセッション用ヘルパーはビューにも自動的に読み込まれる
            * コントローラーはApplicationコントローラにこのモジュールを読み込ませれば、どのコントローラでも使えるようになる
                * ここの違いはしっかり抑えたい。
                    * ヘルパーはビューで自動的に呼ばれる
                    * コントローラの場合モジュールを読みこむ必要あり

```
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper #ここでincludeすることで、全てのコントローラーで使えるようになる
end
```

##### 8.2.1 log_inメソッド

* sessionメソッドを使って、単純なログインを行えるようにする
    * sessionメソッドはハッシュのように扱える
    * `session[:user_id] = user.id`
        * ユーザーのブラウザ内の一時cookiesに暗号化済みのユーザーIDが自動で作成
        * `session[:user_id]`を使ってユーザーIDを元通りに取り出せる
        * cookiesメソッドと違い、sessionメソッドで作成された一時cookiesは、ブラウザを閉じた瞬間に有効期限がなくなる

* 様々な場所でloginメソッドを使うためSessionsヘルパーにlog_inという名前のメソッドを定義

* sessionメソッドで作成した一時cookiesは自動的に暗号化
    * 攻撃者がたとえこの情報をcookiesから盗み出すことができたとしても、それを使って本物のユーザーとしてログインすることはできない
        * cookiesメソッドで作成した「永続的セッション」ではそこまで断言できない
            * 上記の場合はセッションハイジャックという攻撃を受ける可能性が常にある

* sessionとcookieの違いや使い分けがイマイチわからない
    * ９章でcookieが出てくるのでそこでしっかり違いを比べたい
