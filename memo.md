# Rails tutorial memo

## 20200625

### 第1章 ゼロからデプロイまで

* Railsだけでしか使えない基礎的な知識に基づくのではなく、ウェブ開発の基礎を学ぶことを重点とした高度な技術について学ぶ。
* 技術的に困難な課題を解決するために必要なのはスキルは2つのスキル（熟練）が必要
    * ハードスキル (操作方法などの定型化しやすいスキル) 
    * ソフトスキル (デバッグなどの定型化しにくいスキル)
* 技術は知っていればよいというものではなく、エラーメッセージを検索して調べたりなど見極める力も必要。
    * デバッグとかをつい怠ってしまうと感じている。`Rails.logger`や`◯◯.inspect`をもっと使うことも意識する。 
* 改めてRails tutorialで学べることが多くて驚いている。
    * MVCやREST、ジェネレータ、マイグレーション、ルーティング、ERBなどなど、今まではなんとなくで理解していたものが多いので、言葉で説明できるようにしたい。

#### 1.1 はじめに

* Rubyが柔軟性があるからこそ、Railsが簡潔で使いやすくなっている。
    * DSL (ドメイン固有言語) ???　⇨　https://www.jetbrains.com/ja-jp/mps/concepts/domain-specific-languages/
* Railsは最新のWebテクノロジーやフレームワーク設計に素早く適応している。だからこそ進化が早い。
* 多様なコミュニティがあるから、エラーに遭遇すると検索すれば関連する情報がすぐ見つかる。


##### 1.1.1 前提知識

* Rails チュートリアルでもProgateが紹介されているとは驚いた。
* 演習
    * Ruby gemはどのWebサイトにありますか？
        * https://rubygems.org/
    * 現時点でのRailsの最新バージョンはいくつですか？
        * Ruby on Rails 6.0.3
    * Ruby on Railsはこれまでに何回ダウンロードされたでしょうか？
        * すぐにはみつからず、、、。

##### 1.1.2 この本における取り決め

* エラーメッセージをGoogleで検索することは、実際の現場でも使われている基本的なテクニック
    * 何かわからなければ随時調べる。

#### 1.2 さっそく動かす

* ここからRubyなどのインストールを開始。久しぶりに開発環境を整える。
* 一番最初にチュートリアルをやったときはAWS Cloud9(クラウドIDE)だったのがなんだか懐かしい、、、、
    * 無事rails newができた、、、

## 20200626

##### 1.2.1 開発環境

* Cloud9は使わないので割愛

##### 1.2.1 Railsをインストールする

* インストール済み

#### 1.3 最初のアプリケーション

* Webフレームワークではディレクトリとファイルの構造は標準化されている。そのメリットがファイル/ディレクトリ構造が標準化されていることで他の開発者の書いたRailsのコードが読みやすくなること。
* rails new実行！

##### 1.3.1 Bundler

* gem 'uglifier', '>= 1.3.0' だったら、1.3.0以上なら最新をインストール。
* gem 'coffee-rails', '~> 4.0.0'だったら、4.0.0より大きく4.1より小さい場合にインストール。

##### 1.3.2 rails server

* 演習
    * Rubyのバージョンはいくつになっていますか?
        *  2.7.1
    * Railsのバージョンはいくつになっていますか?
        * 5.2.4.3

##### 1.3.3 Model-View-Controller (MVC)

* RailsはMVC (model-view-controller) というアーキテクチャパターンを採用している。MVCでは、アプリケーション内のデータ（ユーザー情報など）と、データを表示するコードを分離している。
* Model
    * アプリケーションが扱うデータ
* View
    * ユーザーへの出力処理
* Controller
    * 必要な処理をModelやViewに伝える
* 上記3つがそれぞれ独立して互いに連携しているのが特徴。

#### 1.3.4 Hello, world!

* 演習まで完了

#### 1.4 Gitによるバージョン管理

* 仕事をする上では欠かせないGitについてスタート

###### 1.4.1 インストールとセットアップ

* Gitにおけるコミットは、あくまでローカルマシン上での操作であること。
	* git pushコマンドで変更をリモートリポジトリにプッシュすることでリモートへ反映。

###### 1.4.2 Gitのメリット

* 読了

###### 1.4.3 Bitbucket

* GitHubで行うので軽く目を通すのみ。
* GitHubにてpush完了

###### 1.4.4 ブランチ、編集、コミット、マージ

* チュートリアルでは出てきたgit commandは業務で毎日使うコマンドが多く困ることはなかった。
    * しかし git branch -D　と　git branch -dなどの違いがわからない。(ここら辺は都度調べれば良さそう)
        * 個人的に一番いまだにわからないのが、fast-forwardとnon-fast-forward。調べたりしているがいまいち理解ができず苦手。
        * cherry-pickやrevertも好きではない、、、。

####　1.5 デプロイする

* Phusion Passenger???
* 一通りのデプロイ環境を提供するEngine YardやRails Machine???
* クラウドサービスを提供するEngine Yard CloudやHeroku??
    * Heroku以外馴染みのない言葉が多かった。

## 20200627

##### 1.5.1 Herokuのセットアップ

* herokuのコマンドが約一年ぶりで忘れていた。（現状頻繁に使うことはないので必要に応じて調べれば良さそう）
    * heroku create (Herokuサーバーにサンプルアプリケーションの実行場所を作成)
    * heroku keys:add(SSHキー)
     * SSHとかについて理解が浅い。何度か調べてはいるが口で説明ができない。

##### 1.5.2 Herokuにデプロイする (1)

* git push heroku master (Gitを使ってHerokuにリポジトリをプッシュ)
    * fetch とか mergeの理解が浅い。
        * 上記2つを同時にやるのがpullなのは理解している。。。。

##### 1.5.3 Herokuにデプロイする (2)

* 無事にデプロイ完了。
    * https://polar-falls-51413.herokuapp.com/

##### 1.5.4 Herokuコマンド

* heroku rename 新しい名前
* 演習
    * Herokuアプリのログを表示するコマンドは？
        * heroku logs

#### 1.6 最後に

* この賞で学んだこと.
    * 開発環境のセットアップやバージョン管理、本番環境へのデプロイの方法。

##### 1.6.1 本章のまとめ

 * この章で理解が不十分だと感じたこと。
    * MVCへの理解。概要はわかるが言葉では説明できない。
    * RESTはMVCよりも理解が浅い。
    * gitコマンドの理解度。
        * チュートリアルに出るコマンドは問題なく使える。
            * しかしcherry pick や revert fast-forwardやnon-fast-forward、fetch mergeの各コマンドの理解が浅い。
    * SSHあたりのセキュリティ面についての理解も自信ない。
        * SSHについては「これから学ぶmacOSターミナル」で概要は読んではいる。
            * 暗号化された通信が可能で安全なリモートログインを可能にするものであると認識している。
    * Bundlerについても詳しく知らずに使っている。
        * とりあえずbundle installやbundle updateを使っていた。

## 20200628

### 第2章 Toyアプリケーション

* scaffoldを通じてRailsアプリの構造とRailsで推奨されているRESTアーキテクチャについて学ぶ
    * RESTについて言葉で説明できないのでこの章でしっかり身につける。

#### 2.1 アプリケーションの計画

* ここは第1章でやったこととほぼ同じ。
    * routeとcontrollerを変えて、アクションの追加。

* 改めて最初にgit push する流れがイマイチなので復習

* git init　(Gitリポジトリの作成)
* git add ファイル名
* git commit -m "メッセージ"
* git remote add origin URL名
* git remote -v 上記で登録された内容の確認
* git push -u origin master
    * -uって何だろう？
        * 成功時に上流ブランチとして設定される。
            * 上流ブランチ（Upstream branch）」とは、あるローカルブランチが、履歴を追跡するように設定したリモートブランチの事を指します
                * そのブランチ上で発生したすべての更新をそのまま取り込む事を追跡するという。

* Webアプリを作る際は構造を表すためのデータモデルを最初に作成するのが通常の流れ。

##### 2.1.1 ユーザーのモデル設計

* 読了

##### 2.1.2 マイクロポストのモデル設計

* ユーザーと関連付ける必要があるので、マイクロポストの投稿者を記録するためのuser_idも追加

#### 2.2 Usersリソース

* Rails 5以前のバージョンでは、db:migrateコマンドはrailsコマンドではなくrakeコマンドが使われていました。
    * Rakeってものについてあまり知らない。

* Rails 4以前のアプリケーションでは、rakeコマンドのバージョンをGemfileで定義しているため、Bundlerのbundler execコマンドを通して実行する必要。
    * bundle exec rake db:migrate 
        * このbundle execについての理解が浅い。

##### 2.1.2 ユーザーページを探検する

* 実際にUsersリソースの挙動の確認完了。

##### 2.2.2 MVCの挙動

* RESTとは、アーキテクチャのスタイルの1つ
* RailsにおけるRESTとは？
    * アプリケーションを構成するコンポーネント (ユーザーなど) を「リソース」としてモデル化することを指す
        * リソースは、リレーショナルデータベースの作成/取得/更新/削除 (CRUD) 操作と、4つの基本的なHTTP requestメソッド (POST/GET/PATCH/DELETE) の両方に対応しています。
        * RESTfulなスタイルを採用することで、作成すべきコントローラやアクションの決定が楽になるのがメリット。

* Active Recordのおかげで便利になって、User.allやfirstを用いて簡単に操作できることは理解しているがその中身についてはよくわからない。

##### 2.2.3 Usersリソースの欠点

* 現状の状態だとvalidationなどもなく欠点が多い。

#### 2.3 Micropostsリソース

* 読了

##### 2.3.1 マイクロポストを探検する

* 実際にMicropostsリソースの挙動の確認完了。

##### 2.3.2 マイクロポストをマイクロにする

* validationの追加。
    * 基本的なvalidationに関しては理解している。

##### 2.3.3 ユーザーはたくさんマイクロポストを持っている

* 1人のユーザーに対して複数のマイクロポストがあるから、has_many
*  1つのマイクロポストは1人のユーザーにのみ属するから、belongs_to
    * 上記の関連付けの結果、User.first.micropostsなどのメソッドが使えるようになる。
        * 関連付けの結果使えるようになるメソッドの理解が浅い。(基本的なbuild等のみ)

##### 2.3.4 継承の階層

* モデルはActionController::Baseを継承することで、モデルオブジェクトはデータベースにアクセスできるようになる。
* コントローラーも同様にActionController::Baseを継承している。
    * 上記のようにActiveRecord::BaseやActionController::Baseを継承していることで、便利になっていることはわかっているが、そもそもActionController::BaseやActionController::Baseについてはよくわかっていない。


##### 2.3.5 アプリケーションをデプロイする

* デプロイ完了

#### 2.4 最後に

* MVCモデルやRESTアーキテクチャに触れることができた。

##### 2.4.1 本章のまとめ

* RailsのRESTには、標準的なURLセットと、データモデルとやりとりするためのコントローラアクションが含まれている。

* この章で理解が不十分だと感じたこと
    * Railの思想についての理解（RESTについてなど）
    * データモデル同士を関連付け
        * 関連付けを行うことで使用できるようになるメソッドへの理解が甘い。
            * 上記に関しては実際にコンソールを叩いて覚えて行きたい。
    * ActiveRecordやActionControllerへの理解。
        * 上記があることで、Railsが便利になっていることは何となく理解はしているが、深い知識がまだまだ足りない。

### 第3章 ほぼ静的なページの作成

* 静的なページの作成と自動テストのコードを書いていく。
* テストを書くメリット。
    * リファクタリングなどを行う時にテストが通ることを確認しながらできる点。

#### 3.1 セットアップ

* bundle install --without production
    * 上記のオプションをつけることで、production環境でしか使わないgemはインストールしないようにしておくことができる。
        * 一回このオプションをつけると次回以降はこのオプションは暗黙的に実行される。

* bundle updateやbundle installの明確な違いがわからない。

* 今後こまめにHerokuへデプロイする。
    * こまめにやることで、エラーなども早めに検知することができる。

#### 3.2 静的ページ

* 読了

##### 3.2.1 静的なページの生成

* rails generateってコマンドも便利だと感じていたが細かい内容についてはよくわかっていない。
    * rails generate することでいい感じに必要な複数のファイルなどを作成してくれるものだと認識して深くは理解していない。（所謂便利コマンド）

* 改めてのメモ、、、コントローラーは複数形、モデルは単数形
    * ex) usersテーブル　userモデル

    * Rubyはクラス名にキャメルケースを使う慣習
    * さらにファイル名をスネークケースで記述する慣習がある

* rails gを間違えた時の操作について理解してなかったのでメモ
    * rails generate controller StaticPages home helpを間違えたため消したい時は、、、
        * rails destroy  controller StaticPages home helpを行えはrails gで作られたファイルも削除される。
    * モデルの場合も同様で、rails generate model User name:string email:stringを消す場合は、
        *  rails destroy model User(モデル名以外は引き数はいらない)

* ページ表示までの流れ 
    * /static_pages/homeというURLにアクセスする
        * StaticPagesコントローラを参照
            * homeアクションに記述されているコード
                * そのアクションに対応するビュー出力
                    * アクション名とviewファイルの名前は対応している

* 演習　
    * 作成 rails generate controller Foo bar baz 
    * 削除 rails  destroy controller Foo bar baz

##### 3.2.2 静的なページの調整

* Viewの微調整完了

#### 3.3 テストから始める

* テスト駆動開発 (TDD)
    * ます「正しいコードがないと失敗するテスト」を書く
        * 次に正しいコードを書いてそのテストがパスするようにする。

* テストのメリットを改めて再確認する
    * 以前のバグが再発したり機能の追加/変更に副作用が生じたりすることを防止できる。
    * コードを安全にリファクタリングできる
    * アプリケーションの設計やシステムの他の部分とのインターフェイスを決めるときにも役に立つ

##### 3.3.1 最初のテスト

*  minitestの文法はあまりわからないが、RSpecで勉強したのでコードは読めそう。

##### 3.3.2 Red

* テスト駆動開発のサイクルの最初のステップは「失敗するテストを最初に書く」
    * 次にアプリケーションのコードを書いて成功させる (パスさせる）
        *  (必要なら)リファクタリングする

##### 3.3.3 Grveen

* 実際にTDDを実行。
* 実際の開発でも習慣化できると良さそう。

##### 3.3.4 Refactor

* テストをきちんと書いているからこそリファクタリングがしやすくなる。
    * テストがあるとリファクタリングした際などの他への副作用などを確認できるからである。

#### 3.4 少しだけ動的なページ

* 読了

##### 3.4.1 タイトルをテストする (Red)

* assert_selectメソッドでは、特定のHTMLタグが存在するかどうかをテスト

##### 3.4.2 タイトルを追加する (Green)

* テストが通ることを確認

##### 3.4.3 レイアウトと埋め込みRuby (Refactor)

* 同じコードを繰り返すことはDRYの原則に反する。
    * もし重複するコードを見つけたら、共通化できないか考える癖をつける。

* <%= yield %>の部分に各ページの内容をレイアウトに挿入
    * yieldは確かprocだったような、、、
        * procはいまだによくわからない。

* Asset Pipelineの仕組みについても理解が浅い、（第5章で出てくるのでそこで深める）
* CSRFなどのセキュリテイに関してもよくわかっていない。

* 演習
    * Contactページが存在することを確認するテストを書く　⇨　テストが落ちることを確認。
        * route　⇨　controller　⇨　view　の順番で修正し無事にテストが通ることを確認。

* このぐらいの小規模のものであれば特に困ることなくできそう。
    * おそらく去年はここらへんもビクビクしながらやっていたと思う、、、、笑

##### 3.4.4 ルーティングの設定

* routeを追加することによるroot_pathなどのヘルパーメソッドを確認するなら、rails／infoが便利そう？

#### 3.5 最後に
　
* https://cryptic-river-78728.herokuapp.com/ へデプロイ完了。

##### 3.5.1 本章のまとめ

* 理解が不十分と感じた点
    * yieldについての理解
        * procで出てきたのは覚えている。
    * Asset Pipelineなどの仕組み

#### 3.6 高度なセットアップ

* 読了

##### 3.6.1 minitest reporters

* 読了

##### 3.6.2 Guardによるテストの自動化

* コラム 3.4. Unixのプロセス
    * Unixなどについてのよくわかっていない。
        * ps aux などのコマンドもあまり使ったことがないので理解が追いついていない。

### 第4章 Rails風味のRuby

* 読了

#### 4.1 動機

* 読了

##### 4.1.1 組み込みヘルパー

* Railsの組み込み関数stylesheet_link_tagにもRubyの4つの概念が存在
    * Railsの組み込み関数
    * カッコを使わないメソッド呼び出し
    * シンボル
    * ハッシュ

##### 4.1.2 カスタムヘルパー

* 組み込み関数は自分でも作ることができ、それをカスタムヘルパーと呼ぶ

* helperに書くべきもの、draperに書くべきものなどの違いがわからない。
    * controllerやmodelが肥大化するのを避けるためには、適切な箇所にメソッドを書くことが不可欠。
        * しかしcontroller、model、helper、draper各所に適切に書くべきものの理解が曖昧。

#### 4.2 文字列とメソッド

* そういえばちょっとしたRubyの挙動を確認するときは、irbとかpryとか使っているが、両者の違いがわかっていない。

* Rubyの日本語の有名なリファレンス ⇨ https://docs.ruby-lang.org/ja/
    * あまりこういったリファレンスを今まで使ってなかった。

##### 4.2.1 コメント

* 読了

##### 4.2.2 文字列

* 今までは意識してなかったが、コンソールは入力したそれぞれの行を評価した結果を表示し、文字列リテラルの場合には文字列自身が表示される。

* putsの戻り値はnil
* シングルクォートは、入力した文字をエスケープせずに「そのまま」保持するときに便利。\n、\tなど

## 20200630

##### 4.2.3 オブジェクトとメッセージ受け渡し

* オブジェクトとはいつでもメッセージに応答するもの
* そもそもオブジェクト（指向）に対する理解が浅い。

##### 4.2.4 メソッドの定義

* 引数にデフォルト値を含めてると、変数に引数を渡すことも渡さないこともできます。
* Rubyのメソッドには「暗黙の戻り値がある」
    * メソッド内で最後に評価された式の値が自動的に返されること

##### 4.2.5 titleヘルパー、再び

* モジュールは、関連したメソッドをまとめる方法の１つ
    * includeでモジュールを読み込むことができる

* Rubyではincludeが必要だが、Railsでは自動的にヘルパーモジュールを読み込んでくれるので、include行をわざわざ書く必要がない。
    * ここら辺のRailsが裏側で行なってくれている便利な機能についてイマイチ理解できていない。
        * full_titleメソッドは全てのviewで使用可能

#### 4.3 他のデータ構造

* 読了

## 20200630

##### 4.3.1 配列と範囲演算子

* 配列 (array) は、特定の順序を持つ要素のリスト

* push(<<)は!がないが破壊的メソッド

* 文字列に対しても範囲オブジェクトが
    * ('a'..'e').to_a ⇨　 ["a", "b", "c", "d", "e"]

##### 4.3.2 ブロック

* ブロックは、Rubyの極めて強力な機能であり、かつわかりにくい機能
    * もっともよく使うメソッドの一つであるため、理解を深めると武器になりそう。

* Ruby共通の慣習
    * 短い1行のブロックには波カッコ使う
    * 長い1行や複数行のブロックにはdo..endを使う。
        * 上記2つは結合のレベル？に違いなどがあるらしいが、細かいことなので割愛。

*  `%w[A B C].map(&:downcase)`のような書き方も一般的。
    * 最低限読めるようにはなっておかないといけない。

##### 4.3.3 ハッシュとシンボル

* インデックスとして整数値以外のものも使える点が配列と異なる

* ハッシュは配列と似ている。
    * 1つの重要な違いとして、ハッシュでは要素の「並び順」が保証されないという点

* シンボルは、Ruby以外ではごく一部の言語にしか採用されていない特殊なデータ形式
    * Rubyからメインにプログラミングに触れたので。シンボルに対しては馴染みがあったつもりだが、シンボルは多くの言語では採用されていないとは、、、

* ハッシュの中のハッシュ
    * ちょっと苦手かも、、、配列の配列はわかっているし、それと基本的な考え方は同じ、、、だと思う。

```
 params = {}        # 'params' というハッシュを定義する ('parameters' の略)。
=> {}
 params[:user] = { name: "Michael", email: "michel@example.com" }
=> {:name=>"Michael", :email=>"michel@example.com"}
 params
=> {:user=>{:name=>"Michael", :email=>"michel@example.com"}}
 params[:user][:email]
=> "mhartl@example.com"
```

* ハッシュもeachメソッドを使える。
    * ブロックの変数はキーと値の2つになる。

##### 4.3.4 CSS、再び

* 以下のコードについて読む。

```
stylesheet_link_tag 'application', media: 'all',
                                   'data-turbolinks-track': 'reload'
```

* そもそも意識はしてなかったが、`stylesheet_link_tag`はメソッド
    * 以前教わった、`validates`もメソッド。
* 上記のstylesheet_link_tagメソッドには2つの引数がある。
    * 最初の引数である文字列は、スタイルシートへのパスを示している。
        * 次の引数であるハッシュには2つの要素があり、最初の要素はメディアタイプを示し、
            次の要素はRails 4.0で追加されたturbolinksという機能をオンにしている。

* ハッシュがメソッド呼び出しの最後の引数である場合は、波カッコを省略できる

```
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }
```

## 20200701

#### 4.3 他のデータ構造

* 改めてのメモ
    * Rubyではあらゆるものがオブジェクト
        * メソッドをまとめるのにクラス
        * 多くのオブジェクト指向言語と同じく、クラスからインスタンスが生成されることでオブジェクトが作成
        * メソッドをまとめるのにクラス

##### 4.4.1 コンストラクタ

* クラス名に対してnewメソッドを呼び出すことを名前付きコンストラクタという
    * ex) `s = String.new("foobar") `

* Hash.new はハッシュのデフォルト値を引数に取ります。(キーが存在しない場合のデフォルト値)
    * 今まで考えもしなかった新しい発見だった。

```
h = Hash.new
=> {}
h[:foo]            # 存在しないキー (:foo) の値にアクセスしてみる
=> nil
h = Hash.new(0)    # 存在しないキーのデフォルト値をnilから0にする
=> {}
h[:foo]
=> 0
```

##### 4.4.2 クラス継承

* クラスの階層について
    * ex)  String < Object < BasicObject

* Rubyにおけるすべてのクラスは最終的にスーパークラスを持たないBasicObjectクラスを継承
     * Rubyではあらゆるものがオブジェクトである"ということの技術的な意味

* selfがよくわからなくなることがある。
    * 色々な場面で出てくるselfが何を指しているのか曖昧になる時がある。

```
class Word < String             # WordクラスはStringクラスを継承する
# 文字列が回文であればtrueを返す
   def palindrome?
    self == self.reverse        # selfは文字列自身を表します
   end
end
```

##### 4.4.3 組み込みクラスの変更

* Rubyでは組み込みの基本クラスの拡張が可能
    * 既存のクラスに対して新しいメソッドの追加やオーバーライドができる。

* blank?もRailsがRubyに追加した具体例の一つ

##### 4.4.4 コントローラクラス

* Railsのコントローラーも同じように階層的に継承がある。
    * StaticPagesController < ApplicationController < ActionController::Base 
                   < ActionController::Metal < AbstractController::Base < Object
                   
* 重要な点 
    * Railsのアクションには戻り値がない。（返される値は重要ではない）
        * home アクションはWebページを表示するためのものであり、値を返すためのものではなかった。
            * そして、第3章では一度もStaticPagesController.newを実行しませんでした。しかし上手く動いている。
                * RailsはRubyで書かれているが、既にRubyとは別物。Railsのクラスは、普通のRubyオブジェクトと同様に振る舞うものもありますが、多くのクラスにはRailsの魔法が振りかけられている。
                    そのためRailsはRubyとは切り離して学習する必要があります。

* 言われてみると、確かに〇〇.newとかしてなかった。

## 20200702

##### 4.4.5 ユーザークラス

```
class User
  attr_accessor :name, :email

  def initialize(attributes = {}) # ← ここの書き方に慣れない   initialize(name, email) ← こっちば馴染みある
    @name  = attributes[:name]                                  @name = name
    @email = attributes[:email]                                 @email = email
  end     

  def formatted_email
    "#{@name} <#{@email}>"
  end
end
```

* initialize(attributes = {})の書き方に馴染みがないと感じた。
    * initialize(name, email) の方の書き方なら理解は出来ていると思っている。。

* マスアサインメント (mass assignment) と呼ばれる技法
    * 名前に馴染みなかった。。。

## 20200703

#### 4.5 最後に

* GitHubへpush済み

##### 4.5.1 本章のまとめ

* Rubyの組み込みクラスには配列、範囲、ハッシュなどがある
    * 他の組み込みクラスについても軽く触れてみよう

* Rubyの世界では、すべてがオブジェクト
    * オブジェクト指向というものに親しみを持てるように再度「オブジェクト指向」というもにについて知っておきたい

* 本章で苦手だと感じたこと
    * ハッシュに対しての理解。特に引数にハッシュが来る場合
    * selfについて（インスタンスメソッド内のselfやクラスメソッド内のクラスなどについての区別）
    * ブロックについてももう少し理解を深めると武器になるはず
        * each、map、selectなどは理解しているとは思う。

    * Railsに対するコードに新たな発見があった。
        * validatesやstylesheet_link_tagってものがメソッドということを意識してなかった。

### 第5章 レイアウトを作成する

* Bootstrapフレームワークを組み込みデザインを加える
* パーシャル、Railsのルーティング、Asset Pipelineについて触れる
    * 上記３つ規則などを改めて理解する。
    * 特にAsset Pipelineはイマイチ理解していないので、この機会にしっかり覚える。
* 統合テスト (Integration Test)」についても学ぶ

#### 5.1 構造を追加する

* Bootstrapを使ってデザインを当てていく
    * デザインについてはコピペで進めていくので良さそう

## 20200704

##### 5.1.1 ナビゲーション

* HTML5は比較的新しく、一部のブラウザ (特に旧式のInternet Explorer) ではHTML5のサポートが不完全である場合がある。
    * そのため、以下のようなJavaScriptのコード (通称: HTML5 shim (or shiv))を使ってこの問題を回避する

```
<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js">
  </script>
<![endif]-->
```

* `<!--[if lt IE 9]>`の意味
    * IE) のバージョンが9より小さい場合 (if lt IE 9) にのみ、囲まれている行を実行するという意味
        * Railsのコードではなく、Internet Explorerで特別にサポートされているコメント
            * その結果、Firefox、Chromeに影響を与えずに済むようになっている。

* Railsヘルパーのlink_toについて改めて学習
    * link_toの第1引数はリンクテキスト、第2引数はURL, 第3引数はオプションハッシュ
        * 第3引数のオプションハッシュは必須ではない
            * 上記については覚える必要はなく、都度調べれば解決

* curlコマンドについての理解。
    * 手軽にHTTPリクエストができるコマンド

* 画像を表示
    * 生成されたHTMLを確認するとsrc属性にはimagesィレクトリ名が含まれていない
        * assetsディレクトリ内の他のディレクトリ (imagesやjavascripts、stylesheetsなど) も同様
            * 高速化のための仕組み
                * こういった仕組みについて理解が浅い

* 演習
    * 画像の取得 curl -OL cdn.learnenough.com/kitten.jpg
    * mvコマンドを使って移動 mv kitten.jpg app/assets/images

##### 5.1.2 BootstrapとカスタムCSS

* Bootstrapをインストール
    * あまり使わない技術なので、ここらへんはささっと！

* app/assets/stylesheets/はAsset Pipelineの一部

##### 5.1.3 パーシャル (partial)

* Railsヘルパーであるrenderを使う
    * `<%= render 'layouts/shim' %>`でapp/views/layouts/_shim.html.erbを探す
        * ファイル名 _shim.html.erb の先頭にあるアンダースコアがポイント
            * renderについての理解を深めたい。⇨ Railsガイドなどをみる

#### 5.2 Sassとアセットパイプライン

* 最近のRailsに追加された機能の中で最も特筆すべき機能の１つがCSS、JavaScript、画像などの静的コンテンツの生産性と管理を大幅に強化するAsset Pipeline
    * ここでAsset Pipelineの理解を深める

##### 5.2.1 アセットパイプライン

* 3つの主要な機能が理解の対象になる
    * それがアセットディレクトリ、マニフェストファイル、プリプロセッサエンジン
        * 上記のようなものは今までおろそかにしていたので、ここで理解を深め苦手意識を無くしたい

* アセットディレクトリ
    * Railsのアセットパイプラインでは、静的ファイルを目的別に分類する、標準的な３つのディレクトリが使われている
        * app/assets: 現在のアプリケーション固有のアセット
        * lib/assets: あなたの開発チームによって作成されたライブラリ用のアセット
        * vendor/assets: サードパーティのアセット 
            * 上記のディレクトリにはそれぞれのアセットクラス用のサブディレクトリがある。
                * app/assetsの場合、次のような画像用、JavaScript用、CSS用のサブディレクトリがある

* マニフェストファイル
    * 静的ファイル (アセット) を上記の場所へそれぞれ配置すれば、マニフェストファイルを使って、それらをどのように1つのファイルにまとめるのかをRailsに指示することができる。
        * 実際にアセットをまとめる処理を行うのはSprocketsというgem。
            * マニフェストファイルはCSSとJavaScriptには適用されますが、画像ファイルには適用されない
                * このようなRailsの裏側の仕組み？というものを理解していない気がする。
                    * なんとなく「便利にうまいことしてくれている」という感じで流していた
    
    * アプリケーションのCSS用マニフェストファイルの例
        * ` *= require_tree .`はapp/assets/stylesheetsディレクトリ (サブディレクトリを含む) 中のすべてのCSSファイルが、アプリケーションCSSに含まれるようにしている。
        * ` *= require_self`で、pplication.css自身もその対象に含めている。

* プリプロセッサエンジン
    * 必要なアセットをディレクトリに配置してまとめた後、Railsはさまざまなプリプロセッサエンジンを介してそれらを実行し、ブラウザに配信できるようにそれらをマニフェストファイルを用いて結合し、サイトテンプレート用に準備する。
        * どのプリプロセッサを使うのかをファイルの拡張子を使って判断する
            * .scss, .coffee, .erbなど。
    * プリプロセッサエンジンは、繋げて実行する (chain) ことができる。
        * ex) foobar.js.erb.coffee
            * 上の拡張子の場合は、CoffeeScriptとERbの両方で実行されます (コードは右から左へと実行されますので、この例ではCoffeeScriptが最初に実行される

* 本番環境での効率性
    * Asset Pipelineの最大のメリットの1つ
        * 本番のアプリケーションで効率的になるように最適化されたアセットも自動的に生成されること
            * 今までは、CSSとJavaScriptを整理するために、機能を個別のファイルに分割し、(インデントを多用して) 読みやすいフォーマットに整えていた。
                * 上記の方法だと本番環境には非効率で、ページの読み込みが遅くなりユーザーが離れていく原因となった。
                    * しかし、Asset Pipelineを使うことで全てのスタイルシートを1つのCSSファイルやJSファイルにまとめてくれ、さらには不要な空白やインデントを削除してくれるので、結果としてファイルサイズを最小化してくれる。
        
##### 5.2.2 素晴らしい構文を備えたスタイルシート

* Sass は、スタイルシートを記述するための言語
    * cssの強化版
        * 重要な機能は変数と機能
* ここは簡単に読む程度に留めておく。

#### 5.3 レイアウトのリンク

* `#`で代用していたリンクを書き換える
    * `<a href="/static_pages/about">About</a>`のように書けるが、Railsは名前つきルートを使うのが慣習
        * `<%= link_to "About", about_path %>`のように書く
            * このように書くことで、about_pathの定義を変えればabout_pathが使われているすべてのURLを変更できるため柔軟性が高くなる

##### 5.3.1 Contactページ

* contactページの追加

##### 5.3.2 RailsのルートURL

* rootメソッドを使ってルートURL "/" をコントローラーのアクションに紐付けていた
    * rootもメソッドなのか、、、、！
        * ルートURLを定義すると、root_pathやroot_urlといったメソッドを通してURLを参照することができるようになる
            * 前者はルートURL以下の文字列を、後者は完全なURLの文字列
            * 基本的には_path書式を使い、リダイレクトの場合のみ_url書式を使うようにする
                * HTTPの標準としては、リダイレクトのときに完全なURLが要求されるため(ただし、ほとんどのブラウザではどちらの方法も機能する)

```
root_path -> '/'
root_url  -> 'http://www.example.com/'
```

* 演習
    * 名前付きルートの変更には`as`が使える
        * `get '/help', to: 'static_pages#help', as: 'helf'`とすると、、、、
        * help_pathがhelf_pathになる

##### 5.3.3 名前付きルート

* 完了

##### 5.3.4 リンクのテスト

* 統合テストを使うと、アプリケーションの動作を端から端まで (end-to-end) シミュレートしてテストすることができる
    * テスト作成用のコマンド
        * `rails generate integration_test site_layout`

* 今回のテストの流れ
    * ルートURL (Homeページ) にGETリクエストを送る
    * 正しいページテンプレートが描画されているかどうか確かめる
    * Home、Help、About、Contactの各ページへのリンクが正しく動くか確かめる

#### 5.4 ユーザー登録: 最初のステップ

* ユーザー登録ページへのルーティングを作成

##### 5.4.1 Usersコントローラ

* Usersコントローラを作成
    * 前回同様`rails g`コマンドを使って作成
        * 最初に作られるpathをget  '/signup',  to: 'users#new’に変更する

##### 5.4.2 ユーザー登録用URL

* get ’/signup’と記述したことでsignup_pathという名前付きルートができる
    * 名前つきルートなども基本は理解しているが、たまにasオプションなどを見ると??となってしまう

#### 5.5 最後に

* git push 完了
* Herokuへもデプロイ完了

##### 5.5.1 本章のまとめ

* Railsのパーシャル
* SassとAsset Pipelineは、(開発効率のために切り分けられた) CSSの冗長な部分を圧縮し、本番環境に最適化した結果を出力する
* Railsのルーティングでは自由にルールを定義することができ、また、その際に名前付きルートも使えるようになる
* 統合テストは、ブラウザによるページ間の遷移を効率的にシュミレーションできる

* 本章で苦手だと感じたこと
    * routeへの深い理解
        * 基本的な知識はあるが、asオプションなどを使ってこなかったことによるオプションへの理解
    * Asset Pipelineの仕組み
        * 今回の5章を通じて少しは理解できがた、説明できるか？といえばまだ出来なさそう
    * SassやCSSに対する深い理解
        * 今回の学習のメインではないので割愛しても良さそう
    * root_pathやroot_urlの使い分けなど

### 第6章 ユーザーのモデルを作成する

* ユーザー用のデータモデルの作成とデータを保存する方法について学ぶ

#### 6.1 Userモデル

* 今のままでは新しいユーザーの情報を受け取っても保存する場所がない
    * なので、情報を保存するためのデータ構造を作成する（モデル）

* Railsでは、データベースを使ってデータを長期間保存する
    * データベースとやりとりをするデフォルトのRailsライブラリはActive Record
        * Active Recordは、データオブジェクトの作成/保存/検索のためのメソッドを持っている
    
* Railsにはマイグレーション (Migration) という機能がある
    * データの定義をRubyで記述することができる

##### 6.1.1 データベースの移行

* Railsでユーザーをモデリングするときは、属性を明示的に識別する必要がない
    * Railsはデータを保存する際にデフォルトでリレーショナルデータベース使う

* コントローラ名には複数形を使い、モデル名には単数形を用いる
* rails g modelで作成
* 間違えても rails destroy model で簡単に削除可能

* rails g modelの結果、マイグレーションファイルが作成される。
    * モデル名は単数形 (User) ですが、テーブル名は複数形 (users)
        * マイグレーションの細かいカスタマイズ（index）の追加などはあまり活用できていない。
            * 現状だとファイルが作成されているだけなので、マイグレーションの適用するために`rails db:migrate`のコマンドを打つ

* schema.rbとは
    * データベースの構造を追跡するためのもの。
        * このファイルを見れば現在のdbの構造を知ることができる

##### 6.1.2 modelファイル

* Userモデルは自動的にActiveRecord::Baseを継承しているので、最初から様々な機能を持っている
    * コンソールでnewなどを使用できることを確認

##### 6.1.3 ユーザーオブジェクトを作成する

* rails console --sandboxって使い方をほぼ忘れかけていた
* オブジェクトが有効か
    * `.valid?`を使う
    * User.createは、trueかfalseを返す代わりに、ユーザーオブジェクト自身を返す
        * つまり変数にも代入可能

##### 6.1.4 ユーザーオブジェクトを検索する

* Active Recordには、オブジェクトを検索するための方法がいくつもある
    * findではidで検索
    * find_byはid以外の属性でも検索できる
        * 値がないときはnil findは例外が発生する
            * ここら辺の使い分けって難しく感じる
    * ActiveRecord::Relationは各オブジェクトを配列として効率的にまとめてくれるクラス

##### 6.1.5 ユーザーオブジェクトを更新する

* update_attributesでも更新ができる
    * 属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行う
        * しかし１でも検証に失敗するとupdate_attributesの呼び出しは失敗する
* update_attributeには、検証を回避するといった効果がある

#### 6.2 ユーザーを検証する

* Active Record では検証 (Validation) という機能を通して、制約を追加することができる
* 検証に引っかかった場合にエラーメッセージを表示する

##### 6.2.1 有効性を検証する

* モデルのバリデーション機能は、テスト駆動開発とまさにピッタシの機能
    * バリデーション機能は強力だが、うまく動いているか自信を持つのが難しい
        * そこでテストの出番

* 具体的なテスト方法
    * まず有効なモデルのオブジェクトを作成
    * その属性のうちの1つを有効でない属性に意図的に変更
    * バリデーションで失敗するかどうかをテスト
    * 念のため、最初に作成時の状態に対してもテストを書いておき、最初のモデルが有効であるかどうかも確認

##### 6.2.2 存在性を検証する

* Presenceを用いて検証する
    * ここではユーザーがデータベースに保存される前にnameとemailフィールドの両方が存在することを保証

* 改めて、、、、validatesは単なるメソッド

* 検証に失敗した際には、errorsオブジェクトを使って確認すれば便利

```
user.errors.full_messages
=> ["Name can't be blank"]

 u.errors.messages
=> {:name=>["can't be blank"], :email=>["can't be blank"]}

u.errors[:email]
=> ["can't be blank"
```

##### 6.2.3 長さを検証する

* ユーザーの名前はサンプルWebサイトに表示されるものなので、名前の長さにも制限を与える必要がある
    * lenghtを用いる

* lengthの検証で引っかかった場合のエラーメッセージ

```
user.errors.full_messages
=> ["Name is too long (maximum is 50 characters)", "Email is too long (maximum is 255 characters)"]
```

##### 6.2.4 フォーマットを検証する

* email属性の場合は、有効なメールアドレスかどうかを判定するために、もっと厳重な要求を満たさなければならない
    * メールアドレスのパターンに合っているかを検証する必要がある
        * メールアドレスのバリデーションは扱いが難しく、エラーが発生しやすい部分なので、有効なメールアドレスと無効なメールアドレスをいくつか用意して、バリデーション内のエラーを検知していく
    * メールアドレスのフォーマットを検証するためには、次のようにformatというオプションを使う

* 正規表現は苦手で本当の最小限のみで終えていた
    * grepなどでも正規表現は便利なので、覚えていく必要あり。

##### 6.2.5 一意性を検証する

* 一意性を保つためのメソッドがvalidatesのuniqueオプション

* 今回の一意性を確認するテストは少し今までとやり方が異なる。
    * 一意性のテストのためには実際にデータベースにレコードを登録する必要あり

```
test "email addresses should be unique" do
  duplicate_user = @user.dup  # userの複製
  @user.save 1つ目のuserをデータベースへ登録
  assert_not duplicate_user.valid? 上記で同じ値をもつデータが登録されているので、ここの検証でダメとなる
end
```

* ちなみにメールアドレスは大文字小文字を区別しない
    * つまり、、、foo@bar.comはFOO@BAR.COMやFoO@BAr.coMと書いても扱いは同じ
        * なので、メールアドレスの検証ではこのような場合も考慮する必要がある
            * : { case_sensitive: false }のオプションをつける
                * 実際にこういった実装をする時につい抜けてしまいそう、、、。

```
test "email addresses should be unique" do
  duplicate_user = @user.dup
  duplicate_user.email = @user.email.upcase
  @user.save
  assert_not duplicate_user.valid?
end
```

* ここで問題がある
    * Active Recordはデータベースのレベルでは一意性を保証していないという問題
        * 仮に登録の際に、素早く連続でクリックされると同じ内容で登録できてしまうケースが発生する
            * 解決するためにはデータベースレベルでも一意性を強制する
                * 具体的にはそのカラムにインデックスを追加する
                    * インデックスには本でいう索引のようなもので検索を効率的に行なってくれる

*  rails generate migration でマイグレーションファイルを直接作成
    * インデックス自体は一意性を強制しない
        * オプションでunique: trueを指定することで強制

```
class AddIndexToUsersEmail < ActiveRecord::Migration[5.1]
  def change
    add_index :users, :email, unique: true
  end
end
```

* fixturesとはテストDB用のサンプルデータが含まれている場所

* 今回のアプリではFoo@ExAMPle.Comとfoo@example.comが同一であると解釈されるべき
    * しかしデータベース上では、別々のものと解釈されてしまう
        * なので、データベースへ保存される直前にすべての文字列を小文字に変換することで対応
            * そこでコールバックの出番
                * 正直、before_actiongぐらいしか使って来なかった

* ` before_save { self.email = email.downcase }`
    * ここでもselfが、、、
        * このselfはユーザーである
            * 右辺のselfは省略可能

## 20200705

#### 6.3 セキュアなパスワードを追加する

* 安全なパスワードを作成するために、ユーザが入力したデータをそのままではなく、ハッシュ化してDBに保存する
    * Rubyのハッシュ化とは別物

* ユーザーの認証は、、、、 
    * パスワードの送信、ハッシュ化、データベース内のハッシュ化された値との比較という流れ
        * ハッシュ化されたパスワード同士を比較していることがポイント

##### 6.3.1 ハッシュ化されたパスワード

* `has_secure_password`というRailsのメソッドを呼び出すだけで完了
    * このメソッドを追加すると、、、
        * データベース内のpassword_digestという属性に保存できる
        * 2つのペアの仮想的な属性 (passwordとpassword_confirmation) が使えるようになる
            * 存在性と値が一致するかどうかのバリデーションも追加される
        * authenticateメソッドが使えるようになる (引数の文字列がパスワードと一致するとUserオブジェクトを、間違っているとfalseを返すメソッド)
    * has_secure_password機能を使うためには条件がある
        * モデル内にpassword_digestという属性が含まれていること
        * 最先端のハッシュ関数であるbcryptが必要

* カラム追加用のマイグレーション
    * rails generate migration add_password_digest_to_users password_digest:string
        * 末尾にto_usersをつけることでusersテーブルにカラムを追加するマイグレーションファイルをRailsが自動的に作成してくれる

##### 6.3.2 ユーザーがセキュアなパスワードを持っている

* 演習

    * userオブジェクトに有効な名前とメールアドレスを与えても、valid?で失敗してしまう際のエラーメッセージ

```
u.errors.full_messages
=> ["Password can't be blank"]
```

##### 6.3.3 パスワードの最小文字数

* has_secure_passwordメソッドは存在性のバリデーションもしてくれる
    * しかし新しくレコードが追加されたときだけに適用される
        * ユーザーが ' ' (6文字分の空白スペース) といった文字列をパスワード欄に入力して更新しようとすると、バリデーションが適用されずに更新されてしまう

* 演習

    * passwordが短い場合のメッセージ

```
u.errors.full_messages
=> ["Password is too short (minimum is 6 characters)"]
```

##### 6.3.4 ユーザーの作成と認証

* コンソールで実際に手動でユーザーを作成する

* 実際に作ったユーザーが￥でpassowrd_digestやauthenticateを使ってみる
    * 間違ったパスワードを渡すとfalse
    * 正しいパスワードを渡すとユーザーオブジェクトを返すようになる

```
user = User.find_by(email: "mhartl@example.com")
 User Load (0.2ms)  SELECT  "users".* FROM "users" WHERE "users"."email" = ? LIMIT ?  [["email", "mhartl@example.com"], ["LIMIT", 1]]

user.password_digest
=> "$2a$12$X0z1i2xymGNRV/B81E7vFej33s/QXPlWOna4dI0dcczUmSjfXKeHi"

user.authenticate("foobaz")
=>false

user.authenticate("foobar")
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2020-07-04 21:44:40", updated_at: "2020-07-04 21:44:40", password_digest: "$2a$12$X0z1i2xymGNRV/B81E7vFej33s/QXPlWOna4dI0dccz...">
```

#### 6.4 最後に

* git push済み

##### 6.4.1 本章のまとめ

* 本章を通じて苦手だと感じた箇所
    * 細かいマイグレーションの使い方
        * 実際の現場では、rails db:migrateしたらrollbackもできることを確認するなどの細かい部分の理解が浅い
        * マイグレーションファイルを実際にあまり自分でカスタマイズしたことがないので、Railsガイドを見ながらやる必要あり
    * 正規表現
        * 本当の基礎しかわかっていない
            * Rails以外でも役立つのでもう少し理解を深める
    * DBに対する知見
        * ex) インデックスを追加することで検索効率が向上するなど
    * Active::Recordのメソッドの細かい違い
        * ex) findとfind_byの使い分けなど、、、、(nilか例外が変えるかは理解している)
        * ex2) update_attributesとupdate_attributeなど（ここに関しては今回学んだ）

### 第7章 ユーザー登録

* 読了

#### 7.1 ユーザーを表示する

* 読了

##### 7.1.1 デバッグとRails環境

* ここからは動的なページを作る（ユーザー情報に基づいて表示が変わる）

* デバッグ情報を追加
    * `<%= debug(params) if Rails.env.development? %>`を追加
        * デバッグ情報はRailsの3つのデフォルト環境のうち、開発環境 (development) だけで表示されるようになる
            * envってものの理解も浅い。環境変数が、、、とかは少し理解はしているが、、、、。

* Railsの3つの環境
    * テスト環境 (test)
    * 開発環境 (development)
        * Rails コンソールの環境はdevelopment(基本的にはオプションで指定しない限りdevelopmentが使われる)
    * 本番環境 (production) 


    * RailsにはRailsというオブジェクトがあり、それには環境の論理値 (boolean) を取るenvという属性がある

    * アプリケーションを本番環境で実行する場合、本番のデータベースが利用できないとアプリケーションを実行できない
        * なので、rails db:migrate RAILS_ENV=productionと明示して本番環境で実行しないといけない

##### 7.1.2 Usersリソース

* ユーザー情報をWebアプリケーション上に表示する
    * RESTアーキテクチャの習慣に従う
        * データの作成、表示、更新、削除をリソース (Resources) として扱う
        * HTTP標準には、これらに対応する４つの基本操作 (POST、GET、PATCH、DELETE) が定義されているので、これらの基本操作を各アクションに割り当てていく

* `resources :users`を追加することで、RESTfulなUsersリソースで必要となるすべてのアクションが利用できるようになる

* paramsってすごい便利だが、その詳細についてはあまり知らないかも
    * paramsってものがどんな情報を持ってくるかを調べる
    * params[:id]は文字列型の "1"
    * findメソッドでは自動的に整数型に変換される

##### 7.1.3 debuggerメソッド

* byebug gemを使ってシステムの状態を調査することはエラーの追跡に便利
    * debuggerを仕込んで学習も良さそう

##### 7.1.4 Gravatar画像とサイドバー

* デフォルトでは、ヘルパーファイルで定義されているメソッドは自動的にすべてのビューで利用できる
    * ヘルパーメソッドはレシーバがいらない

#### 7.2 ユーザー登録フォーム

* 読了

##### 7.2.1 form_forを使用する

* ユーザー登録に欠かせない情報を入力するためのformを作成
    * form_forヘルパーメソッドを使う(今回はform_withではない)

##### 7.2.2 フォームHTML

* form_forのブロック変数fがしていること
    * fオブジェクトは、HTMLフォーム要素 (テキストフィールド、ラジオボタン、パスワードフィールドなど) に対応するメソッドが呼び出されると、@userの属性を設定するために特別に設計されたHTMLを返す
         * `<%= f.text_field :name %>`とすることで、Userモデルのname属性を設定するHTMLを返す
            * よってUserモデルにない属性を指定するとエラーになる

* Railsはformタグを作成するときに@userオブジェクトを使う
    * @userは新しいユーザーなので、 Railsはpostメソッドを使ってフォームを構築する

#### 7.3 ユーザー登録失敗

* 読了

##### 7.3.1 正しいフォーム

* 以下のハッシュはUsersコントローラにparamsとして渡されている
    * params[:id]とか無意識に使っているが、渡している値などをしっかり見る必要がある
    * paramsハッシュには各リクエストの情報が含まれる
    * ハッシュのキーはデバッグ情報では文字列となっていますが、Railsは文字列ではなく、params[:user]のように「シンボル」としてUsersコントローラに渡している点に注意

```
"user" => { "name" => "Foo Bar",
            "email" => "foo@invalid",
            "password" => "[FILTERED]",
            "password_confirmation" => "[FILTERED]"
          }

@user = User.new(params[:user])は以下と同じ意味

@user = User.new(name: "Foo Bar", email: "foo@invalid",
                 password: "foo", password_confirmation: "bar")
```

##### 7.3.2 Strong Parameters

* `@user = User.new(params[:user]) `の実装はセキュリティ的な面で危険
    * paramsハッシュ全体を初期化するという行為が危険
        * params[:user]という中にadminなどの値を紛れ込ませて渡してしまうことも可能である
            * そこでstrong parameterの出番
            * `params.require(:user).permit(:name, :email, :password, :password_confirmation)`
                * 上記の戻り値はハッシュ

##### 7.3.3 エラーメッセージ

* Railsは、エラーメッセージをUserモデルの検証時に自動的に生成してくれる
    * errors.full_messagesオブジェクトは、 エラーメッセージの配列をもつ

```
user.errors.full_messages
=> ["Email is invalid", "Password is too short (minimum is 6 characters)"]
```

* エラーメッセージをブラウザで表示するには、ユーザーのnewページでエラーメッセージのパーシャル (partial) を出力
    * 'shared/error_messages'というパーシャルをrender
        * Rails全般の慣習として、複数のビューで使われるパーシャルは専用のディレクトリ「shared」によく置かれる
            * この「Railsの慣習」というものをもっと理解いきたい
                * Railsの思想やルールを深く理解することを意識する

* Railsは、無効な内容の送信によって元のページに戻されると、CSSクラスfield_with_errorsを持ったdivタグでエラー箇所を自動的に囲む

* 現在のコードだと、、、
    * presence: trueによるバリデーションも、has_secure_passwordによるバリデーションも空のパスワード (nil) を検知する
        * つまり、エラーで同じメッセージが2つ出てしまう
            * 上記に関しては後ほど解決する（allow_nil: trueを使う）

* 演習
    * 未送信のユーザー登録フォームのURLと、送信済みのユーザー登録フォームのURLを比べてると違う
        * http://localhost:3000/signup
        * http://localhost:3000/users
            * formのactionの指定が/usersへリクエストが送られるため

##### 7.3.4 失敗時のテスト

* 今回のテストでは登録ボタンを押した時にユーザーが作成されないことを確認するテスト
    * ユーザーのカウントで確認する

* テストの中身
    * form送信をテストするためには、 users_pathに対してPOSTリクエストを送信
        * postメソッドを使って実現
            * 以下のテストはユーザ数を覚えた後にデータを投稿してみて、ユーザ数が変わらないかどうかを検証

```
assert_no_difference 'User.count' do
  post users_path, params: { user: { name:  "",
                                     email: "user@invalid",
                                     password:              "foo",
                                     password_confirmation: "bar" } }
end
```

#### 7.4 ユーザー登録成功

* 新規ユーザーを実際にデータベースに保存できるようにする

##### 7.4.1 登録フォームの完成

* Railsの一般的な慣習にしたがって、ユーザー登録に成功した場合はページを描画せずに別のページにリダイレクトする
    * 新しく作成されたユーザーのプロフィールページにリダイレクト(users/:id/)
        * `redirect_to @user`と書くが、これは`redirect_to user_url(@user)`と同じ
            * ここら辺のRailsの便利機能をしっかり理解したい

##### 7.4.2 flash

* flashという特殊な変数を使う
    * 変数はハッシュのように使う
        * 成功時には:successというキーにメッセージを代入

* 演習
    * 文字列内の式展開でシンボルを呼び出してみると文字列になる。
        * 普段どんな値が返ってくるかを意識してなかったが新しい発見
    
```
"#{:success}"
=> "success"
```

##### 7.4.3 実際のユーザー登録

* 読了

##### 7.4.4 成功時のテスト

* assert_differenceというメソッドを使ってテスト
    * ここら辺はminitestなので深追いはせずに「何をやっているか」の理解に留める

*  ヘルパーのcontent_tagを今まであまり使ってこなかった
    * 使う際に引数に与えるものなどを調べれば良さそう

#### 7.5 プロのデプロイ

* ユーザー登録をセキュアにするために、本番用のアプリケーションに重要な機能を追加

##### 7.5.1 本番環境でのSSL

* ユーザー登録フォームで送信すると、名前やメールアドレス、パスワードといったデータがネットワーク越しに流されていく
    * このようなネットワークに流れるデータは途中で捕捉できるため、扱いには注意が必要
        * SSLを使い修正していく
            * SSLはローカルのサーバーからネットワークに流れる前に、大事な情報を暗号化する技術

* SSLの有効化
    * SSLを有効化するのも簡単。production.rbという本番環境の設定ファイルの1行を修正するだけ
        * 具体的には、configに「本番環境ではSSLを使うようにする」という設定をするだけ

##### 7.5.2 本番環境用のWebサーバー

* 読了

#### 7.6 最後に

* 読了

##### 7.6.1 本章のまとめ

* debugメソッドを使うことで、役立つデバッグ情報を表示
* Railsには標準で3つ環境が備わっており、それぞれ開発環境 (development)、テスト環境 (test)、本番環境 (production)

* この章で苦手だと感じたこと
    * paramsが渡してくるデータを今まで意識したことなかった
        * なんとなくparams[:id]ってやっておけば良い感じになっていた
         * paramsハッシュには各リクエストの情報が含まれる
    * byebugを使いこなすと便利かも？
        * Rails.loggerやinspectで代用できている
    * .envというものの理解
    * form_forやform_withの使いわけ
        * 現在のRailsのバージョンではform_withが推奨されてはいる
    * SSLなどといったWebの知見が不足

## 20200706

### 第8章 基本的なログイン機構

* ここからログインとログアウト
    * セッションやクッキーなど曖昧なところが多いので、じっくり進める

* ログインの基本的な仕組みとは、ブラウザがログインしている状態を保持し、ユーザーによってブラウザが閉じられたら状態を破棄するといった仕組み
    * この章ではブラウザを閉じるとログインしたユーザー情報を強制的に忘れるようになっている

* 制限や制御の仕組みを認可モデルと呼ぶ
    * ex) ログイン済みかどうかでヘッダー部分を切り替えるなど

#### 8.1 セッション

* HTTPはステートレスなプロトコル
    * つまり状態を保持しない
        * HTTPのリクエスト１つ１つは、それより前のリクエストの情報をまったく利用できない
            * ブラウザのあるページから別のページに移動したときに、ユーザーのIDを保持しておく手段がHTTPプロトコル内にはまったくない

* ユーザーログインの必要なWebアプリケーションではどうする？
    * セッションと呼ばれる半永続的な接続をコンピュータ間 (ユーザーのパソコンのWebブラウザとRailsサーバーなど) に別途設定
        * セッションはHTTPプロトコルと階層が異なる(上の階層にある)
            * そのためHTTPの特性とは別に接続を確保できる

* Railsでセッションを実装する方法
    * cookiesを使う
        * cookiesとは、ユーザーのブラウザに保存される小さなテキストデータ
            * cookiesは、あるページから別のページに移動した時にも破棄されないので、ここにユーザーIDなどの情報を保存できる
                * sessionというRailsのメソッドを使って一時セッションを作成(この一時セッションは、ブラウザを閉じると自動的に終了)

* UsersリソースとSessionリソースの違い
    * UsersリソースではバックエンドでUserモデルを介してデータベース上の永続的データにアクセス
    * Sessionリソースでは代わりにcookiesを保存場所として使う
        * ログインの仕組みの大半は、cookiesを使った認証メカニズムによって構築されている

##### 8.1.1 Sessionsコントローラ

* ログインとログアウトの要素を、Sessionsコントローラの特定のRESTアクションにそれぞれ対応付ける
    * ログインのフォームはnewアクション
    * createアクションにPOSTリクエストを送信すると、実際にログイン
    * destroyアクションにDELETEリクエストを送信すると、ログアウト

* 演習
    * rails routes | grep sessionsを使えばsessionsの名前つきルートを調べられる

## 20200707

##### 8.1.2 ログインフォーム

* ログインフォームとユーザー登録フォームにはほとんど同じ
    * 違いは、4つあったフィールドがEmailとPasswordの2つに減っていることだけ

* 今まではエラーメッセージを出力する場合、Active Recordによって自動生成されるメッセージを使っていた
    * しかし今回はActive Recordを継承しているわけでない
        * つまり自分でエラーメッセージを作成する必要あり

* セッションフォームとユーザー登録フォームの最大の違い
     * セッションにはSessionモデルがない
     * @userのようなインスタンス変数に相当するものがない
        * セッションの場合はリソースの名前とそれに対応するURLを具体的に指定する必要がある

```
前回の@userのケース
form_for(@user)

今回のケース
form_for(:session, url: login_path)
```

* 上記の結果、paramsハッシュに入る値が、メールアドレスとパスワードのフィールドにそれぞれ対応したparams[:session][:email]とparams[:session][:password]になる

```
実際にparamsの値を確認
"session"=>{"email"=>"hoge@example.com", "password"=>"hogehoge"}, "commit"=>"Log in", "controller"=>"sessions", "action"=>"create"}
```

##### 8.1.3 ユーザーの検索と認証

* formから送られてくるparamsの中身は`{ session: { password: "foobar", email: "user@example.com" } }`
    * つまり`params[:session][:email]`のようにデータにアクセスできる
         * 以下のように実装する

```
まずはメールアドレスからユーザー情報を持ってくる
そして、そのユーザーのパスワードが正しいかをauthenticateメソッドを用いて検索している
user = User.find_by(email: params[:session][:email].downcase) # find_byはid以外のユニークは値で検索できる
user && user.authenticate(params[:session][:password])
```

##### 8.1.4 フラッシュメッセージを表示する

* sessionはuserと違いActive Recordを継承していない
    * そのためログインに失敗したときには代わりにフラッシュメッセージを表示する

```
#現在の状態は正しくない
#renderとredirect_toは違うためである。.nowを追加で解決する
flash[:danger] = 'Invalid email/password combination' 
render 'new'
```

## 20200708

##### 8.1.5 フラッシュのテスト

* テストの流れ
    * ログイン用のパスを開く
    * 新しいセッションのフォームが正しく表示されたことを確認
    * わざと無効なparamsハッシュを使ってセッション用パスにPOSTする
    * 新しいセッションのフォームが再度表示され、フラッシュメッセージが追加されることを確認
    * 別のページへ移動する
    * そのページでフラッシュメッセージが表示されていないことを確認する

* `flash.now`のメッセージはその後リクエストが発生したときに消滅
    * 基本、renderの時は`flash.now`をつけると良さそう

#### 8.2 ログイン

* cookiesを使った一時セッションでユーザーをログインできるようにする
    * このcookieはブラウザを閉じると自動的に有効期限が切れる
* セッションを実装するには、様々なコントローラやビューで多くの数のメソッドを定義する必要がある
    * しかしRubyのモジュール機能を使うと、そうしたメソッドを一箇所に置くだけで済む
        * セッション用ヘルパーモジュールもコントローラーを作成した時に作られている
            * Railsのセッション用ヘルパーはビューにも自動的に読み込まれる
            * コントローラーはApplicationコントローラにこのモジュールを読み込ませれば、どのコントローラでも使えるようになる
                * ここの違いはしっかり抑えたい。
                    * ヘルパーはビューで自動的に呼ばれる
                    * コントローラの場合モジュールを読みこむ必要あり

```
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper #ここでincludeすることで、全てのコントローラーで使えるようになる
end
```

##### 8.2.1 log_inメソッド

* sessionメソッドを使って、単純なログインを行えるようにする
    * sessionメソッドはハッシュのように扱える
    * `session[:user_id] = user.id`
        * ユーザーのブラウザ内の一時cookiesに暗号化済みのユーザーIDが自動で作成
        * `session[:user_id]`を使ってユーザーIDを元通りに取り出せる
        * cookiesメソッドと違い、sessionメソッドで作成された一時cookiesは、ブラウザを閉じた瞬間に有効期限がなくなる

* 様々な場所でloginメソッドを使うためSessionsヘルパーにlog_inという名前のメソッドを定義

* sessionメソッドで作成した一時cookiesは自動的に暗号化
    * 攻撃者がたとえこの情報をcookiesから盗み出すことができたとしても、それを使って本物のユーザーとしてログインすることはできない
        * cookiesメソッドで作成した「永続的セッション」ではそこまで断言できない
            * 上記の場合はセッションハイジャックという攻撃を受ける可能性が常にある

* sessionとcookieの違いや使い分けがイマイチわからない
    * ９章でcookieが出てくるのでそこでしっかり違いを比べたい

## 20200709

##### 8.2.2 現在のユーザー

* ユーザーIDを一時セッションの中に安全に置けるようになった
    * そのユーザーIDを別のページで取り出す
        * current_userメソッドを定義して、セッションIDに対応するユーザー名をデータベースから取り出せるようにする

* ユーザーIDが存在しない状態でfindを使うと例外が発生
    * プロフィールページでは適切だった
* ユーザーがログインしていないなどの状況が考えられる今回のケースでは、session[:user_id]の値はnilがありえる
    * そのためfind_byメソッドを使うことにする
        * 以下のようにすると、IDが無効な場合 (=ユーザーが存在しない場合) にもメソッドは例外を発生せず、nilを返す

```
User.find_by(id: session[:user_id])
```

* 以下のように定義する
    * セッションにユーザーIDが存在しない場合はnilになる
        * current_userメソッドが１リクエスト内の処理で何度も呼び出されてしまうと、呼び出された回数と同じだけデータベースへの問い合わせが発生してしまい、結果として処理が完了するまでに時間がかかる
            * これってつまり、、、？

```
def current_user
  if session[:user_id] #true（値があれば）
    User.find_by(id: session[:user_id])
  end
end
```

* Rubyの慣習に従って、User.find_byの実行結果をインスタンス変数に保存
    * 結果として、１リクエスト内におけるデータベースへの問い合わせは最初の１回だけになる
        * 以後の呼び出しではインスタンス変数の結果を再利用
            * ここら辺の効率化？に対する理解が浅い気がする、、、・

```
if @current_user.nil?
  @current_user = User.find_by(id: session[:user_id])
else
  @current_user
end
```

* 上記をさらに簡潔に書くと、、、、

```
@current_user = @current_user || User.find_by(id: session[:user_id])

# さらに簡潔に、、、nilガードを使う

@current_user ||= User.find_by(id: session[:user_id])
```

* 上記はコードを読むことに関しては理解できる
    * しかし自分が実装するときに書けるかは別問題な気がする

* current_userメソッドが完成
    * ユーザーがログインしているかどうかに応じてアプリケーションの動作を変更可能

* ここまででログイン機能が大体完成した
    * しかし全体的に理解が浅い気がする。
        * コードは読めてるが深くは理解していない？のかもしれない

## 202007010

##### 8.2.3 レイアウトリンクを変更する

 * ログインしているときとそうでないときでレイアウトを変更する
    * ヘッダーの表示部分を変更

```
# 例
<% if logged_in? %>
  # ログインユーザー用のリンク
<% else %>
  # ログインしていないユーザー用のリンク
<% end %>
```

* ユーザーがログイン中の状態とは？
    * sessionにユーザーidが存在している
        * current_userがnilではない

* ログアウト用パス
    * `<%= link_to "Log out", logout_path, method: :delete %>`
        * ハッシュがポイント

* プロフィール用リンク
    * `<%= link_to "Profile", current_user %>`
        * 上記は`<%= link_to "Profile", user_path(current_user) %>`の省略系
            * current_userを使うとRailsによってuser_path(current_user)に変換され、プロフィールへのリンクが自動的に生成される
                * 上記の仕組みがよくわからない。覚えるしかないのかな、、、、？

##### 8.2.4 レイアウトの変更をテストする

* ログイン成功のテストを書く
    * そのテストを実行するためには登録済みユーザーとしてログインしておく必要がある
        * データベースにそのためのユーザーが登録されている必要あり
            * テスト用データをfixtureで作成

* 以下がdegestメソッド
    * 今回は詳細は割愛しても良さそう

```
cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
```

* has_secure_passwordで必要となるpassword_digest属性の準備は完了
    * ハッシュ化されていない生のパスワードも参照できると便利だがfixtureではできない
        * この状況を切り抜けるため、テスト用のfixtureでは全員同じパスワード「password」を使う

##### 8.2.5 ユーザー登録時にログイン

* 現状だと登録が終わってもログインしていない状態
    * そこで登録完了後はログインするようにする
        * Usersコントローラのcreateアクションにlog_inを追加

#### 8.3 ログアウト

* ログアウト機能を作成
    * これまで、SessionsコントローラのアクションはRESTfulルールに従っていた
        * セッションを破棄するdestroyアクションも同じ要領で作成

* log_inメソッドの実行結果を消す
    * つまり、`session.delete(:user_id)`のようにして、セッションからユーザーIDを削除

```
def log_out
  session.delete(:user_id)
  @current_user = nil
end
```

#### 8.4 最後に

* push完了！

##### 8.4.1 本章のまとめ

* Railsのsessionメソッドを使うと、別のページに移動するときの状態を保持できる
* sessionメソッドを使うと、ユーザーIDなどをブラウザに一時的に保存できる
* ログインの状態に応じて、ページ内で表示するリンクを切り替える

* この章で苦手だと感じたこと
    * sessionやcookieについての理解
        * ここについては再度復習する
    * 今回は使ってないが、deviseについて
    * コードは読めるが、実際に自分がサクサク書くのは難しそう
    * この章から前回までより難易度が上がっているので、全体的に復習したい

### 第9章 発展的なログイン機構

* 最近のウェブサービスでは、(任意で) ユーザーのログイン情報を記憶しておき、ブラウザを再起動した後でもすぐにログインできる機能が一般的になってきている
    * そこで永続クッキー (permanent cookies) を使ってこの機能を実現

#### 9.1 Remember me 機能

* ユーザーのログイン状態をブラウザを閉じた後でも有効にする [remember me] 機能を実装

##### 9.1.1 記憶トークンと暗号化

* ８章ではsessionメソッドを使ってユーザーIDを保存
    * この情報はブラウザを閉じると消える
        * そこで９章ではセッションの永続化の第一歩として記憶トークン (remember token) を生成し、cookiesメソッドによる永続的cookiesの作成
        * 安全性の高い記憶ダイジェスト (remember digest) によるトークン認証にこの記憶トークンを活用
            * トークンとはパスワードの平文と同じような秘密情報
                * パスワードとトークンとの一般的な違いは、パスワードはユーザーが作成・管理する情報であるのに対し、トークンはコンピューターが作成・管理する情報である点

* sessionメソッドで保存した情報は自動的に安全が保たれる
    * cookiesメソッドに保存する情報はそれがない
        * 特に、cookiesを永続化するとセッションハイジャックという攻撃を受ける可能性がある
            * セキュリティの知見が浅い
                * 記憶トークンを奪って、特定のユーザーになりすましてログインするというもの

* 永続的セッションを作成の流れ
    * 記憶トークンにはランダムな文字列を生成して用いる。
    * ブラウザのcookiesにトークンを保存するときには、有効期限を設定
    * トークンはハッシュ値に変換してからデータベースに保存
    * ブラウザのcookiesに保存するユーザーIDは暗号化
    * 永続ユーザーIDを含むcookiesを受け取ったら、そのIDでデータベースを検索し、記憶トークンのcookiesがデータベース内のハッシュ値と一致することを確認

* 記憶トークンとして何を使うか？
    * 基本的には長くてランダムな文字列であればどんなものでも構わない

```
>> SecureRandom.urlsafe_base64
=> "q5lt38hQDc_959PVoo6b7A"
```

* ユーザーを記憶するには、記憶トークンを作成して、そのトークンをダイジェストに変換したものをデータベースに保存
    * 新しいトークンを作成するためのnew_tokenメソッドを作成

* user.rememberメソッドを作成の流れ
    * 記憶トークンをユーザーと関連付け、トークンに対応する記憶ダイジェストをデータベースに保存
        * user.remember_tokenメソッドを使ってトークンにアクセスできるようにし、かつ、トークンをデータベースに保存せずに実装する必要がある
            * パスワードの実装と同様の手法でこれを解決
                * 今回はremember_tokenのコードを自分で書く必要がある（attr_accessor）

##### 9.1.2 ログイン状態の保持

* ユーザーの暗号化済みIDと記憶トークンをブラウザの永続cookiesに保存して、永続セッションを作成する準備が完了
    * cookieメソッドを使う（sessionのときと同様にハッシュとして使える）
        * 個別のcookiesは、１つのvalue (値) と、オプションのexpires (有効期限) からできている(有効期限は省略可)

```
# 20年後に期限切れになる記憶トークンと同じ値をcookieに保存することで、永続的なセッションを作る例
cookies[:remember_token] = { value:   remember_token,
                             expires: 20.years.from_now.utc }
```

* ユーザーIDをcookiesに保存するには、sessionメソッドで使ったのと同じパターンを使う
    * `cookies[:user_id] = user.id` しかし、このままだとIDが生のテキストとしてcookiesに保存されてしまうので、アプリケーションのcookiesの形式が見え見えでよろしくない
        * 攻撃者がユーザーアカウントを奪い取ることを避けるために署名付きcookieを使用
            * これは、cookieをブラウザに保存する前に安全に暗号化
                * 署名付きcookie...? あまり馴染みの無い言葉、、、

```
cookies.signed[:user_id] = user.id
```

* ユーザーIDと記憶トークンはペアで扱う必要がある
    * cookieも永続化しなくてならない

```
cookies.permanent.signed[:user_id] = user.id
```

* cookiesを設定することで、以後のページのビューで以下ようにcookiesからユーザーを取り出せるようになる
    * cookies.signed[:user_id]では自動的にユーザーIDのcookiesの暗号が解除され、元に戻る

```
User.find_by(id: cookies.signed[:user_id])
```


* 渡されたトークンがユーザーの記憶ダイジェストと一致することを確認
    * bcryptを使ってcookies[:remember_token]がremember_digestと一致することを確認
        * この一致をbcryptで確認するための様々な方法がある

```
BCrypt::Password.new(password_digest) == unencrypted_password
# 今回の場合、上のコードを参考に下のようなコード 
BCrypt::Password.new(remember_digest) == remember_token
```

* 上記のコードを少し詳しく見てみる
    * bcryptで暗号化されたパスワードを、トークンと直接比較している
        * ということは、==で比較する際にダイジェストを復号化している？
            * しかし、bcryptのハッシュは復号化できない
                * そこでbcrypt gemのソースコードを詳しく調べてみると、比較に使っている==演算子が再定義されている
                    * 実際の比較では、==の代わりにis_password?という論理値メソッドが使われている
        
```
BCrypt::Password.new(remember_digest).is_password?(remember_token)
```

* 今までのを参考に記憶トークンと記憶ダイジェストを比較するauthenticated?メソッドを作成

* ここら辺の流れなどは把握できたが、もっと深く理解していきたいので、８〜９章は要復習が必要

##### 9.1.3 ユーザーを忘れる

* ユーザーがログアウトできるようにするために、ユーザーを記憶するためのメソッドと同様の方法で、ユーザーを忘れるためのメソッドを定義する
    * update_attributeを使い、記憶ダイジェストをnilで更新
        * forgetヘルパーメソッドを追加してlog_outヘルパーメソッドから呼び出す

##### 9.1.4 ２つの目立たないバグ

* １つ目
    * 同じサイトを複数のタブ (あるいはウィンドウ) で開いている場合に起きる
        * 今のcurrent_userの使い方では、ユーザーが1つのタブでログアウトし、もう1つのタブで再度ログアウトしようとするとエラーになってしまう
            * これは、もう1つのタブで "Log out" リンクをクリックすると、current_userがnilとなってしまうため
                * つまりlog_outメソッド内のforget(current_user)が失敗する
                    * この問題を回避するためには、ユーザーがログイン中の場合にのみログアウトさせる必要がある

* ２つ目
    * ユーザーが複数のブラウザ (FirefoxやChromeなど) でログインしていたときに起こる
    *  例えば、Firefoxでログアウトし、Chromeではログアウトせずにブラウザを終了させ、再度Chromeで同じページを開くと、この問題が発生
        * ユーザーがFirefoxからログアウトすると、user.forgetメソッドによってremember_digestがnilになる
            * logged_in?がtrueの場合に限ってlog_outを呼び出すように変更
                * つまり当たり前のことだが、「ログインしている場合」にログアウトする
    * 一方、Chromeを閉じたとき、session[:user_id]はnilになる (これはブラウザが閉じたときに、全てのセッション変数の有効期限が切れるため)。
        * しかし、cookiesはブラウザの中に残り続けている
            * 記憶ダイジェストがnilの場合にfalseを返すように修正

#### 9.2 [Remember me] チェックボックス

* チェックボックスがオンのときにユーザーを記憶し、オフのときには記憶しないようにする
    * 実装はわずか1行ですむ
        * ログインフォームから送信されたparamsハッシュには既にチェックボックスの値が含まれてる
            * `params[:session][:remember_me]`がチェックボックスがオンのときに'1'になり、オフのときに'0'になる
                * よって、'1'の時は`remember(user)`を'0'の時は`forget(user)`を呼ぶ


#### 9.3 [Remember me] のテスト

* テストを書く理由の１つ
    * ユーザーを永続化するコードの中心部分が、実はまだまったくテストされていないから
        * 上記をテストするためにしいテストのテクニックを覚える必要がある

##### 9.3.1 [Remember me] ボックスをテストする

* ユーザーが記憶されるにはログインが必要
    * テスト内でユーザーがログインできるようにするためのヘルパーメソッドを定義する
        * ログインに成功すれば、cookies内部のremember_tokenキーを調べることで、ユーザーが保存されたかどうかをチェックできる

* cookiesの値がユーザーの記憶トークンと一致することを確認できれば理想的だが、現在の設計ではテストでこの確認を行うことはできない
    * 今は関連するcookiesがnilであるかどうかだけをチェックすればよい

* テストの書き方など考慮するべきことなどが少しずつ複雑になってきて難しく感じる

##### 9.3.2 [Remember me] をテストする

* current_user内のある複雑な分岐処理については、これまでまったくテストが行われていない
    * テスト手順
        * fixtureでuser変数を定義する
        * 渡されたユーザーをrememberメソッドで記憶する
        g* current_userが、渡されたユーザーと同じであることを確認

#### 9.4 最後に

* 読了

##### 9.4.1 本章のまとめ

* Railsでは、あるページから別のページに移動するときに状態を保持することができる
* 記憶トークンと記憶ダイジェストをユーザーごとに関連付けて、永続的セッションが実現

* 本章で理解が浅いと感じたところ
    * 8章、９章共に深く理解することが難しいと感じた
    * sessionとcookieの違いについても曖昧
    * このレベルのテストを書くのは難しそうだと感じた
    * ログインとなると、gemをイメージするがここで自分で0から実装することも大切なので要復習

## 20200721

#### ８章 改めてのメモ

* 今までは`form_for(@user)`としていたが、今回はUserモデルがない為に、`form_for(:session, url: login_path)`としている
    * `:session`としていすることにより `params[:session][:email]`や`params[:session][:password]`のように値を参照できるようになるため。

* `current_user`メソッドなどは読めば理解はできていると思うが、実際にパパッと書けるかは別問題

* 8.2.4 レイアウトの変更をテストのパートの以下がイマイチ理解できない

```
def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end
```

## 20200723

### 第10章 ユーザーの更新・表示・削除

* 読了

#### 10.1 ユーザーを更新する

* ユーザー情報を編集することはユーザーを新規作成と似ている部分が多い
    * ユーザーを編集するためのeditアクション(newの代わり)を作成することである
    * PATCHリクエスト(postの代わり)に応答するupdateアクションを作成する

##### 10.1.1 編集フォーム

* ユーザー作成のnewで作った内容とeditの内容は同じ
    * ユーザーが新規なのか、それともデータベースに存在する既存のユーザーであるかの違い

##### 10.1.2 編集の失敗

* update_attributesを使って更新
     * ここはユーザーをcreateした時と似ている

##### 10.1.3 編集失敗時のテスト

* 完了

##### 10.1.4 TDDで編集を成功させる

* テスト駆動開発を使ってユーザーの編集機能を実装する
    * 先にテストを書いて、そのテストが通るように実装することで受け入れ可能な状態になったかを判断できる

* 現状だとパスワードやパスワード確認の欄を空にしておくとバリデーションで引っかかる
    * allow_nil: trueというオプションを追加することで解決

* ここで疑問
    * allow_nil: trueを追加することで、新規に登録するときにも空パスワードを許してしまうのでは？
        * has_secure_passwordではオブジェクト生成時に存在性を検証するようになっているため、空のパスワード (nil) が新規ユーザー登録時に有効になることはない。
            * has_secure_passwordはすごい便利だからこそ、本当の使いかたをしっかり把握して使うとより良さそう

#### 10.2 認可

* 認証はサイトのユーザーを識別することであり、認証はそのユーザーが実行可能な操作を管理すること

##### 10.2.1 ユーザーにログインを要求する

* 現状のサイトの問題点は、誰でもユーザー情報を編集できてしまう
    * なのでユーザーにログインを要求し、かつ自分以外のユーザー情報を変更できないする
        * before_actionを使う

* テストの網羅性を意識することの大切さ

##### 10.2.2 正しいユーザーを要求する

* ログインを要求するだけでは不十分
    * ユーザーが自分の情報だけを編集できるようにする必要がある

* ユーザーの情報が互いに編集できないことを確認するために、サンプルユーザーをもう一人追加
    * これにより相互に認可の部分をテストすることができる

```
#正しいユーザーを確認するためのメソッド
def correct_user
  @user = User.find(params[:id])
  redirect_to(root_url) unless @user == current_user
end
```

##### 10.2.3 フレンドリーフォワーディング

* ログインしていないユーザーが編集ページにアクセスしようとしていたなら、ユーザーがログインした後にはその編集ページにリダイレクトされるようにするのが望ましい動作
    * これがユーザーに優しい仕様である

* これをテストで実現すると、、、、
    * まず編集ページにアクセスし、ログインした後に、(デフォルトのプロフィールページではなく) 編集ページにリダイレクトされているかどうかをチェックするといったテスト

* 実際に実装すると、、、
    * ユーザーを希望のページに転送するには、リクエスト時点のページをどこかに保存する
        * store_locationとredirect_back_orの2つのメソッドを使って実現
            * 転送先のURLを保存する仕組みは、8.2.1でユーザーをログインさせたときと同じで、sessionを使用
            * また、requestオブジェクトも使用（request.original_urlでリクエスト先が取得できる）
        * store_locationメソッドでは、 リクエストが送られたURLをsession変数の:forwarding_urlキーに保存
        * フォワーディング自体を実装するには、redirect_back_orメソッドを使う

## 20200724

#### 10.3 すべてのユーザーを表示する

* 読了

##### 10.3.1 ユーザーの一覧ページ

* indexページはログインしたユーザーにしか見せないにする

##### 10.3.2 サンプルのユーザー

* ユーザー数を一気に増やすためにFaker gemを追加
    * seed.rbに記入

##### 10.3.3 ページネーション

* 現状だと１ページに大量のユーザーが表示されている問題があるのでそれを解消
    * will_paginate gem とbootstrap-will_paginate gemを追加
        * 細かい使いかたは割愛

##### 10.3.4 ユーザー一覧のテスト

* 完了

##### 10.3.5 パーシャルのリファクタリング

* 下記のようにリファクタリングできる
    * `render @users`でいい感じにRailsが展開してくれるがこのような便利な機能をうまく理解できない、、、

```
<ul class="users">
  <% @users.each do |user| %>
    <li>
      <%= gravatar_for user, size: 50 %>
      <%= link_to user.name, user %>
    </li>
  <% end %>
</ul>

<ul class="users">
  <%= render @users %>
</ul>

# 以下はパーシャル
<li>
  <%= gravatar_for user, size: 50 %>
  <%= link_to user.name, user %>
</li>
```

#### 10.4 ユーザーを削除する

* destroyの実装
    * ただし、今回はadmin権限があるユーザーのみがdestroyできるようにする

##### 10.4.1 管理ユーザー

* 論理値をとるadmin属性をUserモデルに追加する
    * admin?メソッドも使えるようになっている

##### 10.4.2 destroyアクション

* 管理者だけに削除のリンクが表示されるようにする
    * そのさい、管理者自身の削除リンクは表示されないようにする
        * また、loginしている状態出ないといけないので、before_actionにも追加しておく

```
<% if current_user.admin? && !current_user?(user) %>
    | <%= link_to "delete", user, method: :delete,
                                data: { confirm: "You sure?" } %>
<% end %>
```

* 今のままだと問題がある
    * コマンドラインでDELETEリクエストを直接発行するという方法でサイトの全ユーザーを削除してしまうことができる
        * destroyアクションにもアクセス制御を行う

```
# 管理者かどうか確認
def admin_user
    redirect_to(root_url) unless current_user.admin?
end
```

###### 10.4.3 ユーザー削除のテスト

* 完了

#### 10.5 最後に

* push済み

##### 10.5.1 本章のまとめ

* beforeフィルターを使って、認可 (アクセス制御) を実現
* フレンドリーフォワーディングとは、ログイン成功時に元々行きたかったページに転送させる機能
* render @usersを実行すると、自動的に_user.html.erbパーシャルを参照し、各ユーザー表示する
    * ここの仕組みをイマイチ理解できてない
* boolean型のadmin属性をUserモデルに追加すると、admin?という論理オブジェクトを返すメソッドが自動的に追加される
    * ここは意外に知らなかったかも？

* この章で理解がイマイチと感じた箇所
    * before_actionの追加について
        * 「どのユーザーは◯◯できる」みたいな設計レベル？の話しが苦手かも
    * フレンドリーフォワーディングについて
    * （意識してなかっただけだが）boolean型をモデルに追加すると論理オブジェクトを返すメソッドが自動的に追加されること

### 第11章 アカウントの有効化

* 現状だと登録さえすれば全ての機能を使える
    * 今回は登録したメールアドレスが「本当に本人のものか？」を検証する機能を実装する

* アカウントを有効化する段取り
    * ユーザーの初期状態は「有効化されていない」
    * ユーザー登録が行われたときに、有効化トークンと、それに対応する有効化ダイジェストを生成
    * 有効化ダイジェストはデータベースに保存しておき、有効化トークンはメールアドレスと一緒に、ユーザーに送信する有効化用メールのリンクに仕込む
    * ユーザーがメールのリンクをクリックしたら、アプリケーションはメールアドレスをキーにしてユーザーを探し、データベース内に保存しておいた有効化ダイジェストと比較することでトークンを認証
    * ユーザーを認証できたら、ユーザーのステータスを「有効化されていない」から「有効化済み」へ

#### 11.1 AccountActivationsリソース

* セッション機能を使って、アカウントの有効化という作業を「リソース」としてモデル化する
    * 必要なデータ (有効化トークンや有効化ステータスなど) をUserモデルに追加

* RESTのルールに従うとPATCHリクエストとupdateアクションになるべき
    * しかし、有効化リンクはメールでユーザーに送られる
        * ユーザーがこのリンクをクリックすれば、それはブラウザで普通にクリックしたときと同じであり、その場合ブラウザから発行されるのは (updateアクションで使うPATCHリクエストではなく) GETリクエスト
            * このため、ユーザーからのGETリクエストを受けるために、(本来であればupdateのところを) editアクションに変更
                * このあたりの考え方は読めば理解できるが自分で考えられるかは別問題

##### 11.1.1 AccountActivationsコントローラ

* sessionsリソースのときと同様に、AccountActivationsリソースを作る

##### 11.1.2 AccountActivationのデータモデル

* 有効化のメールには一意の有効化トークンが必要
    * 簡単に思いつくのは、、、
        * 送信メールとデータベースのそれぞれに同じ文字列を置いておく方法
            * しかしセキュリティ的にハッシュ化しないのは危険
    * 今回は仮想的な属性を使ってハッシュ化した文字列をデータベースに保存する
        * ここの仕組み（仕様）については何となくの理解でしかないので、しっかり復習する

* ユーザーが新しい登録を完了するためには必ずアカウントの有効化が必要になる
    * つまり、有効化トークンや有効化ダイジェストはユーザーオブジェクトが作成される前に作成しておく必要がある
        * 今回は、オブジェクトが作成されたときだけコールバックを呼び出したい(createの時)
            * before_createコールバックが必要

* 今回before_createコールバックを使う目的は、トークンとそれに対応するダイジェストを割り当てるため

```
self.activation_token  = User.new_token
self.activation_digest = User.digest(activation_token)
```

#### 11.2 アカウント有効化のメール送信

* アカウント有効化メールの送信に必要なコードを追加
    * createアクションで有効化リンクをメール送信するため、Action Mailerライブラリを使ってUserのメイラーを追加

```
edit_account_activation_url(@user.activation_token, email: @user.email)
とすることで、、、
account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com
のようになる
```

* 上記は`edit_user_url(user)`が`http://www.example.com/users/1/edit`のと基本的に同じ
    * ここら辺の仕組みが少しずつ深く理解できるようになった

##### 11.2.2 送信メールのプレビュー

* Railsでは、特殊なURLにアクセスするとメールのメッセージをその場でプレビューすることができる
    * あまりメールの機能を使ったことがないので、しっかり理解したい

##### 11.2.3 送信メールのテスト

* 完了

##### 11.2.4 ユーザーのcreateアクションを更新

* createアクションに`UserMailer.account_activation(@user).deliver_now`を追加する
    * 今回の追加により、登録時にログインする必要はなくなるのでそこの部分も変更

#### 11.3 アカウントを有効化する

* editアクションを書いていく

##### 11.3.1 authenticated?メソッドの抽象化

* 有効化トークンとメールをそれぞれparams[:id]とparams[:email]で参照できる 

* これから実装するauthenticated?メソッドでは、受け取ったパラメータに応じて呼び出すメソッドを切り替える手法を使う
    * sendを使った簡易なメタプロのようなもの
        * sendを使って、authenticated?メソッドを書き換える

```
def authenticated?(attribute, token)
  digest = send("#{attribute}_digest")
  return false if digest.nil?
  BCrypt::Password.new(digest).is_password?(token)
end

user.authenticated?(:remember, remember_token)にやれば今までと同じ挙動になる
```

##### 11.3.2 editアクションで有効化

* paramsハッシュで渡されたメールアドレスに対応するユーザーを認証
    * `if user && !user.activated? && user.authenticated?(:activation, params[:id])`を使う

* ユーザーのログイン方法を変更も変更しないといけない
    * ユーザーの有効化が役に立つためには、ユーザーが有効である場合にのみログインできるようにログイン方法を変更する必要がある
        * ここまで頭が回らなそう、、、汗

##### 11.3.3 有効化のテストとリファクタリング

* 簡単なリファクタリングが完了
    * メソッド化してわかりやすくするなどは実際にやると難しいイメージ

#### 11.4 本番環境でのメール送信

* 読了

#### 11.5 最後に

* 読了

##### 11.5.1 本章のまとめ

* Action Mailerについて学んだ
    * 普段使わないので、後日復習＋自作アプリにも取り入れるのも良さそう
* アカウントを有効化させるために、生成したトークンを使って一意のURLを作成

* 本章で理解がイマイチだと感じたこと
    * Action Mailerの理解
    * アカウントを有効化する流れについての理解
        * 本章を読みながら大筋は理解したつもりだが、細かい挙動についてもう少し理解する必要がある
            * ex) authenticated?メソッドについてなど
                * 再度学習する必要ある

### 第12章 パスワードの再設定

* 読了

* 全体の流れ
    * ユーザーがパスワードの再設定をリクエストすると、ユーザーが送信したメールアドレスをキーにしてデータベースからユーザーを見つける
    * 再設定用トークンとそれに対応する再設定ダイジェストを生成
    * 再設定用ダイジェストはデータベースに保存し、再設定用トークンはメールアドレスと一緒に、ユーザーに送信する有効化用メールのリンクに仕込む
    * ユーザーがメールのリンクをクリックしたら、メールアドレスをキーとしてユーザーを探し、データベース内に保存しておいた再設定用ダイジェストと比較
    * 認証に成功したら、パスワード変更用のフォームをユーザーに表示

#### 12.1 PasswordResetsリソース

* セッションやアカウント有効化のときと同様に、まずはPasswordResetsリソースを生成
    * 今回も新たなモデルは作らずに、代わりに必要なデータ (再設定用のダイジェストなど) をUserモデルに追加

##### 12.1.1 PasswordResetsコントローラ

* `rails generate controller PasswordResets new edit --no-test-framework`のようにオプションをつけるとテストファイルを作らないで済む

##### 12.1.2 新しいパスワードの設定

* パスワードの再設定でも、トークン用の仮想的な属性とそれに対応するダイジェストを用意
* 設定用のリンクはなるべく短時間 (数時間以内) で期限切れにするように設定
    * reset_digest属性とreset_sent_at属性をUserモデルに追加

##### 12.1.3 createアクションでパスワード再設定

* ールアドレスをキーとしてユーザーをデータベースから見つける
    * その後パスワード再設定用トークンと送信時のタイムスタンプでデータベースの属性を更新する

#### 12.2 パスワード再設定のメール送信

* 読了

##### 12.2.1 パスワード再設定のメールとテンプレート

* 11章とほぼ同じ
    * つまり11章を深く理解する必要あり

##### 12.2.2 送信メールのテスト

* ここも11章と同じ

#### 12.3 パスワードを再設定する

* PasswordResetsコントローラのeditアクションの実装を進める

##### 12.3.1 editアクションで再設定

* パスワード再設定の送信メールにはリンクが含まれている
    * そのリンクを機能させるためにはviewが必要(edit)

* 今回の作業は少しだけ面倒な点
    * メールアドレスをキーとしてユーザーを検索するためには、editアクションとupdateアクションの両方でメールアドレスが必要
        * メールアドレス入りリンクのおかげで、editアクションでメールアドレスを取り出すことは簡単
            * しかしフォームを一度送信してしまうと、この情報は消える
                * この値はどこに保持しておく必要がある
                    * 隠しフィールドとしてページ内に保存する
                         * `<%= hidden_field_tag>`について調べる必要あり

##### 12.3.2 パスワードを更新する

* 新しいパスワードを更新するためのupdateを実装する
    * 考慮することは４つ
        * パスワード再設定の有効期限が切れていないか
        * 無効なパスワードであれば失敗させる (失敗した理由も表示する)
        * 新しいパスワードが空文字列になっていないか (ユーザー情報の編集ではOKだった)
        * 新しいパスワードが正しければ、更新する

* 以下は「パスワード再設定メールの送信時刻が、現在時刻より2時間以上前 (早い) の場合」という意味

```
def password_reset_expired?
    reset_sent_at < 2.hours.ago
  end
```

##### 12.3.3 パスワードの再設定をテストする

* 概ね11章と同じ

#### 12.4 本番環境でのメール送信 (再掲)

* 読了

#### 12.5 最後に

* 読了

##### 12.5.1 本章のまとめ

* パスワードの再設定は Active Recordオブジェクトではないが、セッションやアカウント有効化の場合と同様に、リソースでモデル化できる
* パスワードを再設定させるために、生成したトークンを使って一意のURLを作る

* 本章で理解が不十分だと感じた部分
    * トークンやdigestについての深い理解（9章から要復習）
    * reset_sent_at < 2.hours.agoについて
        * ここに関しては再度しっかり見れば問題はなさそう
    * ActionMailerの実装や挙動について

## 20200726

### 第13章 ユーザーのマイクロポスト

* 読了

#### 13.1 Micropostモデル

* Micropostモデルを作成する
    * Userモデルとの関連付けがある
        * 親であるユーザーが破棄された場合には自動的に破棄される
            * こういった設計？をいざ自分がやると抜けてしまいそう

##### 13.1.1 基本的なモデル

* String型とText型の違い
    * String型でも255文字まで
    * Text型の方が長い文字を格納できる

* rails g model ~~~~~~~~~ user:references のようにオプションをつけたことによりbelongs_toのコードも追加されている

* Userモデルとの最大の違いはreferences型を利用している点
    * 自動的にインデックスと外部キー参照付きのuser_idカラムが追加
        * インデックスの役割などを再度しっかり確認したい(両方のキーを同時に扱う複合キーインデックスなど)

##### 13.1.2 Micropostのバリデーション

* テストの流れ
    * setupのステップで、fixtureのサンプルユーザーと紐付けた新しいマイクロポストを作成
        * 作成したマイクロポストが有効かどうかをチェック
            * あらゆるマイクロポストはユーザーのidを持っているべきなので、user_idの存在性のバリデーションに対するテストも追加

##### 13.1.3 User/Micropostの関連付け

* 個々のモデル間での関連付けを十分考えておくことは重要
    * 今回の場合はそれぞれのマイクロポストは１人のユーザーと関連付けられる
        * それぞれのユーザーは (潜在的に) 複数のマイクロポストと関連付けられる
            * 基本的な関連付けならわかるが、もっと多くのモデルが出てくると混乱しそう

*  belongs_to/has_many関連付けを使うことで、多くのメソッドをRailsで使えるようになる

```
user.microposts.create
user.microposts.create!
user.microposts.build
micropost.user
user.microposts
user.microposts.find_by
```

##### 13.1.4 マイクロポストを改良する

* デフォルトのスコープ
    * 現状だと順序を考慮していないので、新しいものが最初に表示されるようにする
        * Railsのdefault_scopeメソッドを使う
            * データベースから要素を取得したときの、デフォルトの順序を指定するメソッド
                * `default_scope -> { order(created_at: :desc) }`となる
                    * lambdaを使っている、、、ここは苦手なので復習が必要

* Dependent: destroy
    * ユーザーが破棄された場合、ユーザーのマイクロポストも同様に破棄されるべき
        * has_manyメソッドにオプションを渡してあげる

#### 13.2 マイクロポストを表示する

* 読了

##### 13.2.1 マイクロポストの描画

* 以前も@usersを使ったように、`<%= render @microposts %>`でコレクションを表示する

##### 13.2.2 マイクロポストのサンプル

* seed.rbに追加
    * `User.order(:created_at).take(6)` 作成されたユーザーの最初の６人を取得する

##### 13.2.3 プロフィール画面のマイクロポストをテストする

* テストデータの作成方法などをしっかり覚えていきたい

#### 13.3 マイクロポストを操作する

* Micropostsリソースへのインターフェイスは、主にプロフィールページとHomeページのコントローラを経由して実行される
    * つまり、reateとdestroyがあれば十分

##### 13.3.1 マイクロポストのアクセス制御

* 関連付けられたユーザーを通してマイクロポストにアクセスするので、createアクションやdestroyアクションを利用するユーザーは、ログイン済みである必要がある
    * logged_in_userメソッドをapplication_controllerへ
        * そうすることで全てのコントローラーで使える

##### 13.3.2 マイクロポストを作成する

* micropost/new ページは作らずに、ホーム画面 (つまりルートパス) にフォームを置く

* ユーザーのログイン状態に応じて、ホーム画面の表示を変更する
    * logged_in?メソッドが使える

* _error_messages.html.erbの変更
    * 今までは@userを前提としていたが、今回からは@micropostのことも念頭に入れないといけない
        * f.objectが@userとなる場合と、f.objectが@micropostになる場合

##### 13.3.3 フィードの原型

* まずは現在ログインしているユーザーのマイクロポストをすべて取得

```
def feed
  Micropost.where("user_id = ?", id)
end
```

* Railsは対応する名前のパーシャルを、渡されたリソースのディレクトリ内から探しにいくことができる
    * こういったRailsの便利な機能は一つずつしっかり身に付けたい

##### 13.3.4 マイクロポストを削除する

* 自分が投稿したマイクロポストに対してのみ削除リンクが動作する

* request.referrer || root_urlについて
    * このメソッドはフレンドリーフォワーディングのrequest.urlと似ている
        * 一つ前のURLを返す。今回の場合、Homeページになる
            * 今回の場合はHomeページから削除された場合とプロフィールページから削除された場合の２つがあるため
                * request.referrerを使うことでDELETEリクエストが発行されたページに戻すことができる

##### 13.3.5 フィード画面のマイクロポストをテストする

* 完了

#### 13.4 マイクロポストの画像投稿

* 画像アップロード機能を追加
    * formの追加と投稿された画像そのものが必要になる

##### 13.4.1 基本的な画像アップロード

* carrierwaveを使う
    * ついでにgemは画像をリサイズしたり (13.4.3)、本番環境で画像をアップロードするために使うmini_magick gemとfog gemsも含める
        * CarrierWaveを導入すると、Railsのジェネレーターで画像アップローダーが生成できるようになる

* CarrierWaveでアップロードされた画像は、Active Recordモデルの属性と関連付けされているべき
    * picture属性をMicropostモデルに追加

* CarrierWaveに画像と関連付けたモデルを伝えるためには、mount_uploaderというメソッドを使う

* ここに関してはgemの使い方によるものも多い気がするので、都度必要に応じてREADMEなどをみる

##### 13.4.2 画像の検証

* 細かい問題がいくつかある
    * 画像に対する制限がない
        * 巨大なファイルを上げたり、無効なファイルを上げる問題

* 画像のサイズを制御について
    * こちらは既存のvalidationにない
        * 今まで使っていたvalidatesメソッドではなく、validateメソッドを使う

* クライアント側でも制御するようにfile_fieldタグにacceptパラメータを付与

##### 13.4.3 画像のリサイズ

* MiniMagickというImageMagickとRubyを繋ぐgemを使って画像をリサイズ
    * MiniMagickのドキュメント (英語) を見ると様々な方法でリサイズできることがわかる
        * 詳しくはドキュメントを参照する 

##### 13.4.4 本番環境での画像アップロード

* 読了

#### 13.5 最後に

* 読了

##### 13.5.1 本章のまとめ

* Railsは複数のキーインデックスをサポートしている
    * インデックスについてはRailsガイドなどに目を通したい
* has_manyやbelongs_toを利用することで、関連付けを通して多くのメソッドが使えるようになった
* default_scopeを使うとデフォルトの順序を変更できる
* dependent: :destroyオプションを使うと、関連付けされたオブジェクトと自分自身を同時に削除

* 本章で苦手だと感じたところ
    * インデックスについて
    * 関連付けについての理解
        * 使えるようになるメソッドなどについてはRailsガイドをしっかり見たい
    * デフォルトスコープについて（ラムダについて）
        * 別途Ruby本でも確認する
    * dependent: :destroyオプションなどの役割はわかっているが、一から全て自分が作る時にそこまで頭が回らない可能性がある
    * fixtureの使いこなし


### 第14章 ユーザーをフォローする

* 他のユーザーをフォロー (およびフォロー解除) できる機能を追加
* フォローしているユーザーの投稿をステータスフィードに表示する機能を追加
* Ajaxについても触れる
    * ここはしっかり学んでいきたい

#### 14.1 Relationshipモデル

* フォローする機能を実装するためにはデータモデルが必要
    * 簡単に思いつくのは、has_many (1対多) の関連付けを用いる方法
        * しかし簡単にはいかない
            * そのため has_many_throughを使う

##### 14.1.1 データモデルの問題 (および解決策)

* あるユーザーをフォローしているすべてのユーザーの集合はfollowersとなり、user.followersはそれらのユーザーの配列を表すことになる
    * しかし、この名前付けは逆向きではうまくいかない
        * あるユーザーがフォローしているすべてのユーザーの集合は、このままではfollowedsとなってしまい、英語の文法からも外れてよくない
            * そこで、Twitterの慣習にならい、本チュートリアルではfollowingという呼称を採用する

* followingテーブルと has_many関連付けを使って、フォローしているユーザーのモデリングを行う
    * followingテーブルのそれぞれの行は、followed_idで識別可能
        * それぞれの行はユーザーなので、これらのユーザーに名前やパスワードなどの属性も追加

* 掲載されている図はm問題がある
    * 各行には、フォローしているユーザーのid、名前やメールアドレスまであるため無駄が多い
        * usersテーブルにあるものばかり
            * さらに、、、followersの方をモデリングすると同じような無駄の多いテーブルをさらに作成する必要がある
                * 保守性も悪
                    * なぜならユーザー名を変更するたびに、usersテーブルのそのレコードだけでなく、followingテーブルとfollowersテーブルの両方について、そのユーザーを含むすべての行を更新する必要が出てくるため

* 上記の問題の根本は、必要な抽象化を行なっていないことにある
    * 正しいモデルを見つけ出す方法の1つは、Webアプリケーションにおけるfollowingの動作をどのように実装するかをじっくり考えること
        * この場合アプリケーションによって作成または削除されるのは、2人のユーザーの「関係 (リレーションシップ)」
            * 1人のユーザーは1対多の関係を持つことができ、さらにユーザーはリレーションシップを経由して多くのfollowing (またはfollowers) と関係を持つことができる

* 他の解決しなくてはいけない問題
    * Facebookのような友好関係 (Friendships) では本質的に左右対称のデータモデルが成立
        * Twitterのようなフォロー関係では左右非対称の性質がありえる
            * フォローしている人からフォローされている訳ではない（左右非対称）
                * それぞれを能動的関係 (Active Relationship)と受動的関係 (Passive Relationship)と呼ぶ
                    * ここら辺の設計の話しは難しい、、、というか思いつかなそう

* まずは能動的関係に焦点を当てる
    * フォローしているユーザーはfollowed_idがあれば識別することができる
        * followed_idを通して、usersテーブルのフォローされているユーザーを見つける

* 能動的関係も受動的関係も、最終的にはデータベースの同じテーブルを使う

* Relationship tableについて
    * 複合キーインデックス
        * follower_idとfollowed_idの組み合わせが必ずユニークであることを保証する
            * これにより、あるユーザーが同じユーザーを2回以上フォローすることを防ぐ
                * 自身で何か作る場合でもこの設計レベルまでわかるようになりたい

```
class CreateRelationships < ActiveRecord::Migration[5.1]
  def change
    create_table :relationships do |t|
      t.integer :follower_id
      t.integer :followed_id

      t.timestamps
    end
    add_index :relationships, :follower_id
    add_index :relationships, :followed_id
    add_index :relationships, [:follower_id, :followed_id], unique: true
  end
end
```

##### 14.1.2 User/Relationshipの関連付け

* UserとRelationshipの関連付け
    * 1人のユーザーにはhas_many (1対多) のリレーションシップ
    * リレーションシップは2人のユーザーの間の関係なので、フォローしているユーザーとフォロワーの両方
        * `user.active_relationships.build(followed_id: ...)`を実現したい
            * しかしMicropostの時と大きく違う点がある、、、
                * ActiveRelationshipモデルはない
                * followerというクラス名は存在しない
                    * 上記の問題を解決するためには自分で以下のように必要な箇所を指定する
                        * その結果多くのメソッドを使えるようになる


```
has_many :active_relationships, class_name:  "Relationship",
                                  foreign_key: "follower_id",
                                  dependent:   :destroy
```

```
class Relationship < ApplicationRecord
  belongs_to :follower, class_name: "User"
  belongs_to :followed, class_name: "User"
end
```

##### 14.1.3 Relationshipのバリデーション

* 完了

##### 14.1.4 フォローしているユーザー

* Relationshipの関連付けの核心、followingとfollowersを実装
    * has_many throughを使う
        * 1人のユーザーにはいくつもの「フォローする」「フォローされる」といった関係性がある(「多対多」と呼ぶ)

##### 14.1.5 フォロワー

* user.followersメソッドを追加
    * これは上のuser.followingメソッドと対のもの

* 全体的に複雑になってきたのでしっり復習する

#### 14.2 [Follow] のWebインターフェイス

* フォロー/フォロー解除の基本的なインターフェイスを実装する

##### 14.2.1 フォローのサンプルデータ

* rails db:seedを使ってサンプルデータを作成
    * しっかり中身を理解する

```
users = User.all
user  = users.first
following = users[2..50]
followers = users[3..40]
following.each { |followed| user.follow(followed) }
followers.each { |follower| follower.follow(user) }
```

##### 14.2.2 統計と [Follow] フォーム

* プロフィールページとHomeページを実装してデータを反映させる
    * 現在のユーザーがフォローしている人数と、現在のフォロワーの人数が表示させる

* routesにmemberメソッドを使う
    * この場合のURLは /users/1/following や /users/1/followers のようになる
        * 逆にcollectionの場合はidを指定しない

* フォローのform
    * 2つのフォームの主な違い
        * 上は新規でリレーションを作るのに対して、下のは既存のリレーションを探す
            * フォームはfollowed_idをコントローラに送信する必要があるので、上ではhidden_field_tagメソッドを使い
                * 今一度、hidden_field_tagをしっかり確認する

```
<%= form_for(current_user.active_relationships.build) do |f| %>
  <div><%= hidden_field_tag :followed_id, @user.id %></div>
  <%= f.submit "Follow", class: "btn btn-primary" %>
<% end %>

<%= form_for(current_user.active_relationships.find_by(followed_id: @user.id),
             html: { method: :delete }) do |f| %>
  <%= f.submit "Unfollow", class: "btn" %>
<% end %>
```

##### 14.2.3 [Following] と [Followers] ページ

* フォローしているユーザーを表示するページと、フォロワーを表示するページを作成
    * いずれもプロフィールページとユーザー一覧ページを合わせたような作りになる
    
* 今回、followingとfollowersでは明示的にshow_followという同じビューを出力
    * 1つのviewファイルで十分であるため

* 正しい数が表示されているかどうかと、正しいURLが表示されているかどうかの２つのテスト
    * HTML構造を網羅的にチェックするテストは壊れやすく、生産性を逆に落としかねないため網羅的にテストをしない

##### 14.2.4 [Follow] ボタン (基本編)

* [Follow] / [Unfollow] ボタンを動作させる実装
    * Relationshipsコントローラが必要